package strategygames.backgammon

import org.specs2.matcher.ValidatedMatchers

import strategygames.{ Player, Score, Status }
import strategygames.format.{ FEN => StratFen, Forsyth => StratForsyth, Uci => StratUci }
import strategygames.variant.{ Variant => StratVariant }
import variant.Backgammon

class BackgammonVariantTest extends BackgammonTest with ValidatedMatchers {

  "Backgammon Variant handles dice rolls and moves" should {

    val game = Game.apply(variant.Backgammon)

    "be valid game after first dice roll" in {
      game.diceRoll(List(3, 4)) must beValid.like { g =>
        g._1.situation.moves.values.flatten.size must_== 8
        g._1.situation.player must_== Player.P1
      }

      game.diceRoll(List(4, 3)) must beValid.like { g =>
        g._1.situation.moves.values.flatten.size must_== 8
        g._1.situation.player must_== Player.P2
      }

      game.diceRoll(List(1, 5)) must beValid.like { g =>
        g._1.situation.moves.values.flatten.size must_== 5
        g._1.situation.moves.values.flatten.map(_.toUci.uci).toSet must_== Set(
          "l2k2",
          "a2e1",
          "e1f1",
          "e1j1",
          "g1h1"
        )
      }
    }

    "be valid game after first dice roll and first move" in {
      val actionStrs = List(
        "1/5",
        "l2k2"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.moves.values.flatten.size must_== 3
        g.situation.moves.values.flatten.map(_.toUci.uci).toSet must_== Set(
          "k2f2",
          "a2e1",
          "e1j1"
        )
      }
    }

    "be unchanged after undoing first choice action" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "undo"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        val gamePreUndo = forceValidGameToGame(playActionStrs(actionStrs.dropRight(2)))
        g.actionStrs must_== gamePreUndo.actionStrs
        g.plies must_== gamePreUndo.plies
        g.turnCount must_== gamePreUndo.turnCount
        g.situation.player must_== gamePreUndo.situation.player
        g.situation.board.pieces must_== gamePreUndo.board.pieces
        g.situation.board.pocketData must_== gamePreUndo.board.pocketData
        g.situation.board.unusedDice.sorted must_== gamePreUndo.board.unusedDice.sorted
        g.situation.board.history.lastTurn must_== gamePreUndo.board.history.lastTurn
        g.situation.board.history.currentTurn must_== gamePreUndo.board.history.currentTurn
        g.situation.board.history.score must_== gamePreUndo.board.history.score
        g.situation.board.history.halfMoveClock must_== gamePreUndo.board.history.halfMoveClock
        g.situation.moves.values.flatten
          .map(_.toUci.uci)
          .toSet must_== gamePreUndo.situation.moves.values.flatten.map(_.toUci.uci).toSet
      }
    }

    "be valid game after first dice roll and first two moves" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.moves.values.flatten.size must_== 0
        g.situation.canEndTurn must_== true
        g.situation.board.pipCount(Player.P1) must_== 161
        g.situation.board.pipCount(Player.P2) must_== 167
        g.situation.board.history.currentTurn.map(_.uci) must_== actionStrs
      }
    }

    "be unchanged after undoing second choice action" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "undo"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        val gamePreUndo = forceValidGameToGame(playActionStrs(actionStrs.dropRight(2)))
        g.actionStrs must_== gamePreUndo.actionStrs
        g.plies must_== gamePreUndo.plies
        g.turnCount must_== gamePreUndo.turnCount
        g.situation.player must_== gamePreUndo.situation.player
        g.situation.board.pieces must_== gamePreUndo.board.pieces
        g.situation.board.pocketData must_== gamePreUndo.board.pocketData
        g.situation.board.unusedDice.sorted must_== gamePreUndo.board.unusedDice.sorted
        g.situation.board.history.lastTurn must_== gamePreUndo.board.history.lastTurn
        g.situation.board.history.currentTurn must_== gamePreUndo.board.history.currentTurn
        g.situation.board.history.score must_== gamePreUndo.board.history.score
        g.situation.board.history.halfMoveClock must_== gamePreUndo.board.history.halfMoveClock
        g.situation.moves.values.flatten
          .map(_.toUci.uci)
          .toSet must_== gamePreUndo.situation.moves.values.flatten.map(_.toUci.uci).toSet
      }
    }

    "be unchanged after undoing both choice actions in first turn" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "undo",
        "undo"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        val gamePreUndo = forceValidGameToGame(playActionStrs(actionStrs.dropRight(4)))
        g.actionStrs must_== gamePreUndo.actionStrs
        g.plies must_== gamePreUndo.plies
        g.turnCount must_== gamePreUndo.turnCount
        g.situation.player must_== gamePreUndo.situation.player
        g.situation.board.pieces must_== gamePreUndo.board.pieces
        g.situation.board.pocketData must_== gamePreUndo.board.pocketData
        g.situation.board.unusedDice.sorted must_== gamePreUndo.board.unusedDice.sorted
        g.situation.board.history.lastTurn must_== gamePreUndo.board.history.lastTurn
        g.situation.board.history.currentTurn must_== gamePreUndo.board.history.currentTurn
        g.situation.board.history.score must_== gamePreUndo.board.history.score
        g.situation.board.history.halfMoveClock must_== gamePreUndo.board.history.halfMoveClock
        g.situation.moves.values.flatten
          .map(_.toUci.uci)
          .toSet must_== gamePreUndo.situation.moves.values.flatten.map(_.toUci.uci).toSet
      }
    }

    "be valid game after first turn" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.player must_== Player.P2
        g.situation.board.history.lastTurn.map(_.uci) must_== actionStrs
      }
    }

    "be valid game after first turn and second dice roll" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.moves.values.flatten.map(_.toUci.uci).toSet must_== Set(
          "l1j1x",
          "l1h1",
          "a1b2",
          "a1d2",
          "e2g2",
          "e2i2",
          "g2i2",
          "g2k2x"
        )
        g.situation.canCapture must_== true
      }
    }

    "be valid game after first turn and second turn's dice roll and first move" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.moves.values.flatten.map(_.toUci.uci).toSet must_== Set(
          "l1h1",
          "j1f1",
          "a1d2",
          "e2i2",
          "g2k2x"
        )
        g.situation.board.pieceCountOnBar(Player.P1) must_== 1
        g.situation.board.history.currentTurn.map(_.uci) must_== List("2/4", "l1j1x")
      }
    }

    "be unchanged after undoing capture action" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "undo"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        val gamePreUndo = forceValidGameToGame(playActionStrs(actionStrs.dropRight(2)))
        g.actionStrs must_== gamePreUndo.actionStrs
        g.plies must_== gamePreUndo.plies
        g.turnCount must_== gamePreUndo.turnCount
        g.situation.player must_== gamePreUndo.situation.player
        g.situation.board.pieces must_== gamePreUndo.board.pieces
        g.situation.board.pocketData must_== gamePreUndo.board.pocketData
        g.situation.board.unusedDice.sorted must_== gamePreUndo.board.unusedDice.sorted
        g.situation.board.history.lastTurn must_== gamePreUndo.board.history.lastTurn
        g.situation.board.history.currentTurn must_== gamePreUndo.board.history.currentTurn
        g.situation.board.history.score must_== gamePreUndo.board.history.score
        g.situation.board.history.halfMoveClock must_== gamePreUndo.board.history.halfMoveClock
        g.situation.moves.values.flatten
          .map(_.toUci.uci)
          .toSet must_== gamePreUndo.situation.moves.values.flatten.map(_.toUci.uci).toSet
      }
    }

    "be valid game after first turn and second turn" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "endturn"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.board.pieceCountOnBar(Player.P1) must_== 2
        g.situation.canOnlyRollDice must_== true
      }
    }

    "be unchanged after undoing second capture action" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "undo"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        val gamePreUndo = forceValidGameToGame(playActionStrs(actionStrs.dropRight(2)))
        g.actionStrs must_== gamePreUndo.actionStrs
        g.plies must_== gamePreUndo.plies
        g.turnCount must_== gamePreUndo.turnCount
        g.situation.player must_== gamePreUndo.situation.player
        g.situation.board.pieces must_== gamePreUndo.board.pieces
        g.situation.board.pocketData must_== gamePreUndo.board.pocketData
        g.situation.board.unusedDice.sorted must_== gamePreUndo.board.unusedDice.sorted
        g.situation.board.history.lastTurn must_== gamePreUndo.board.history.lastTurn
        g.situation.board.history.currentTurn must_== gamePreUndo.board.history.currentTurn
        g.situation.board.history.score must_== gamePreUndo.board.history.score
        g.situation.board.history.halfMoveClock must_== gamePreUndo.board.history.halfMoveClock
        g.situation.board.pieceCountOnBar(Player.P1) must_== gamePreUndo.situation.board.pieceCountOnBar(
          Player.P1
        )
        g.situation.moves.values.flatten
          .map(_.toUci.uci)
          .toSet must_== gamePreUndo.situation.moves.values.flatten.map(_.toUci.uci).toSet
      }
    }

    "be unchanged after undoing two capture actions" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "undo",
        "undo"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        val gamePreUndo = forceValidGameToGame(playActionStrs(actionStrs.dropRight(4)))
        g.actionStrs must_== gamePreUndo.actionStrs
        g.plies must_== gamePreUndo.plies
        g.turnCount must_== gamePreUndo.turnCount
        g.situation.player must_== gamePreUndo.situation.player
        g.situation.board.pieces must_== gamePreUndo.board.pieces
        g.situation.board.pocketData must_== gamePreUndo.board.pocketData
        g.situation.board.unusedDice.sorted must_== gamePreUndo.board.unusedDice.sorted
        g.situation.board.history.lastTurn must_== gamePreUndo.board.history.lastTurn
        g.situation.board.history.currentTurn must_== gamePreUndo.board.history.currentTurn
        g.situation.board.history.score must_== gamePreUndo.board.history.score
        g.situation.board.history.halfMoveClock must_== gamePreUndo.board.history.halfMoveClock
        g.situation.moves.values.flatten
          .map(_.toUci.uci)
          .toSet must_== gamePreUndo.situation.moves.values.flatten.map(_.toUci.uci).toSet
      }
    }
  }

  "Backgammon Variant handles endturn" should {
    "be valid game that can endturn early" in {
      val actionStrs = List(
        "4/5",
        "l2h2",
        "a2e1",
        "endturn",
        "4/2",
        "l1h1",
        "l1j1",
        "endturn",
        "5/6",
        "e1j1",
        "l2f2",
        "endturn",
        "4/2",
        "s@k1",
        "a1d2",
        "endturn",
        "6/1",
        "e1k1",
        "j1k1",
        "endturn",
        "6/2"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.canMove must_== false
        g.situation.canLift must_== false
        g.situation.canDrop must_== false
        g.situation.canEndTurn must_== true
        g.situation.canOnlyEndTurn must_== true
        g.situation.board.furthestFromEnd(Player.P1) must_== 20
        g.situation.board.furthestFromEnd(Player.P2) must_== 20
        g.situation.forcedAction.nonEmpty must_== true
      }
      playActionStrs(actionStrs ++ List("endturn")) must beValid.like { g =>
        g.situation.board.unusedDice.isEmpty must_== true
        g.situation.board.usedDice.isEmpty must_== true
        g.situation.canOnlyRollDice must_== true
      }
    }

    "be valid game that can endturn even after a single move/drop/lift" in {
      val actionStrs = List(
        "endturn",
        "3/1",
        "e2h2",
        "g2h2",
        "endturn",
        "5/3",
        "e1j1",
        "l2i2",
        "endturn",
        "4/4",
        "e2i2",
        "e2i2",
        "a1d2",
        "a1d2",
        "endturn",
        "3/1",
        "s@j2",
        "g1h1",
        "endturn",
        "1/6",
        "g2h2",
        "l1f1",
        "endturn",
        "5/5",
        "g1l1",
        "j2e2",
        "a2e1",
        "a2e1",
        "endturn",
        "1/2",
        "s@l1",
        "l1j1",
        "endturn",
        "6/5",
        "endturn",
        "5/1",
        "f1a1",
        "j1i1",
        "endturn",
        "5/3",
        "s@j2",
        "endturn"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.board.unusedDice.isEmpty must_== true
        g.situation.board.usedDice.isEmpty must_== true
        g.situation.canOnlyRollDice must_== true
      }
    }
  }

  "Backgammon Variant handles drops" should {

    "be valid game and obey drop rules and must skip turn when no valid drops" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "endturn",
        "6/6"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.canMove must_== false
        g.situation.canDrop must_== false
        g.situation.canOnlyEndTurn must_== true
      }
    }

    "be valid game and have valid drops when roll is accomodating" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "endturn",
        "2/1"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.canMove must_== false
        g.situation.canDrop must_== true
        g.situation.canOnlyEndTurn must_== false
      }
    }

    "be valid game and obey drop rules and can capture" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "endturn",
        "2/1",
        "s@k2"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.board.pieceCountOnBar(Player.P1) must_== 1
        g.situation.board.pieceCountOnBar(Player.P2) must_== 1
        g.situation.board.pipCount(Player.P1) must_== 183
        g.situation.canMove must_== false
        g.situation.dropsAsDrops.map(_.toUci.uci) must_== List("s@l2")
        g.situation.board.history.currentTurn.map(_.uci) must_== List("2/1", "s@k2x")
      }
    }

    "be unchanged after undoing a drop action" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "endturn",
        "2/1",
        "s@k2",
        "undo"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        val gamePreUndo = forceValidGameToGame(playActionStrs(actionStrs.dropRight(2)))
        g.actionStrs must_== gamePreUndo.actionStrs
        g.plies must_== gamePreUndo.plies
        g.turnCount must_== gamePreUndo.turnCount
        g.situation.player must_== gamePreUndo.situation.player
        g.situation.board.pieces must_== gamePreUndo.board.pieces
        g.situation.board.pocketData must_== gamePreUndo.board.pocketData
        g.situation.board.unusedDice.sorted must_== gamePreUndo.board.unusedDice.sorted
        g.situation.board.history.lastTurn must_== gamePreUndo.board.history.lastTurn
        g.situation.board.history.currentTurn must_== gamePreUndo.board.history.currentTurn
        g.situation.board.history.score must_== gamePreUndo.board.history.score
        g.situation.board.history.halfMoveClock must_== gamePreUndo.board.history.halfMoveClock
        g.situation.dropsAsDrops
          .map(_.toUci.uci)
          .toSet must_== gamePreUndo.situation.dropsAsDrops.map(_.toUci.uci).toSet
        g.situation.canMove must_== gamePreUndo.situation.canMove
        g.situation.canDrop must_== gamePreUndo.situation.canDrop
        g.situation.canOnlyEndTurn must_== gamePreUndo.situation.canOnlyEndTurn
      }
    }

    "be valid game and obey drop rules and can add to own stack" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "endturn",
        "2/1",
        "s@k2",
        "s@l2",
        "endturn"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.board.pieceCountOnBar(Player.P1) must_== 0
        g.situation.board.pieceCountOnBar(Player.P2) must_== 1
      }
    }

    "be unchanged after undoing second drop action" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "endturn",
        "2/1",
        "s@k2",
        "s@l2",
        "undo"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        val gamePreUndo = forceValidGameToGame(playActionStrs(actionStrs.dropRight(2)))
        g.actionStrs must_== gamePreUndo.actionStrs
        g.plies must_== gamePreUndo.plies
        g.turnCount must_== gamePreUndo.turnCount
        g.situation.player must_== gamePreUndo.situation.player
        g.situation.board.pieces must_== gamePreUndo.board.pieces
        g.situation.board.pocketData must_== gamePreUndo.board.pocketData
        g.situation.board.unusedDice.sorted must_== gamePreUndo.board.unusedDice.sorted
        g.situation.board.history.lastTurn must_== gamePreUndo.board.history.lastTurn
        g.situation.board.history.currentTurn must_== gamePreUndo.board.history.currentTurn
        g.situation.board.history.score must_== gamePreUndo.board.history.score
        g.situation.board.history.halfMoveClock must_== gamePreUndo.board.history.halfMoveClock
        g.situation.dropsAsDrops
          .map(_.toUci.uci)
          .toSet must_== gamePreUndo.situation.dropsAsDrops.map(_.toUci.uci).toSet
        g.situation.board.pieceCountOnBar(Player.P1) must_== gamePreUndo.situation.board.pieceCountOnBar(
          Player.P1
        )
        g.situation.board.pieceCountOnBar(Player.P2) must_== gamePreUndo.situation.board.pieceCountOnBar(
          Player.P2
        )
        g.situation.board.pipCount(Player.P1) must_== gamePreUndo.situation.board.pipCount(Player.P1)
        g.situation.canMove must_== gamePreUndo.situation.canMove
      }
    }

    "be unchanged after undoing two drop actions" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "endturn",
        "2/1",
        "s@k2",
        "s@l2",
        "undo",
        "undo"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        val gamePreUndo = forceValidGameToGame(playActionStrs(actionStrs.dropRight(4)))
        g.actionStrs must_== gamePreUndo.actionStrs
        g.plies must_== gamePreUndo.plies
        g.turnCount must_== gamePreUndo.turnCount
        g.situation.player must_== gamePreUndo.situation.player
        g.situation.board.pieces must_== gamePreUndo.board.pieces
        g.situation.board.pocketData must_== gamePreUndo.board.pocketData
        g.situation.board.unusedDice.sorted must_== gamePreUndo.board.unusedDice.sorted
        g.situation.board.history.lastTurn must_== gamePreUndo.board.history.lastTurn
        g.situation.board.history.currentTurn must_== gamePreUndo.board.history.currentTurn
        g.situation.board.history.score must_== gamePreUndo.board.history.score
        g.situation.board.history.halfMoveClock must_== gamePreUndo.board.history.halfMoveClock
        g.situation.dropsAsDrops
          .map(_.toUci.uci)
          .toSet must_== gamePreUndo.situation.dropsAsDrops.map(_.toUci.uci).toSet
        g.situation.canMove must_== gamePreUndo.situation.canMove
        g.situation.canDrop must_== gamePreUndo.situation.canDrop
        g.situation.canOnlyEndTurn must_== gamePreUndo.situation.canOnlyEndTurn
      }
    }

    "be valid game and obey drop rules and can add to own stack" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "endturn",
        "2/1",
        "s@k2",
        "s@l2",
        "endturn",
        "6/5"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.board.pieceCountOnBar(Player.P2) must_== 1
        g.situation.dropsAsDrops.map(_.toUci.uci) must_== List("s@h1")
      }
    }

    "be valid game and be able to move after clearing bar" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "endturn",
        "2/1",
        "s@k2",
        "s@l2",
        "endturn",
        "6/5",
        "s@h1"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.board.pieceCountOnBar(Player.P2) must_== 0
        g.situation.canDrop must_== false
        g.situation.canMove must_== true
        g.situation.moves.values.flatten.map(_.toUci.uci).toSet must_== Set(
          "l1f1",
          "j1d1",
          "h1b1",
          "a1f2",
          "e2k2x"
        )
      }
    }

  }

  "Backgammon Variant handles lifts" should {

    val actionStrs = List(
      "4/5",
      "l2h2",
      "a2e1",
      "endturn",
      "4/2",
      "l1h1",
      "l1j1",
      "endturn",
      "5/6",
      "e1j1",
      "l2f2",
      "endturn",
      "4/2",
      "s@k1",
      "a1d2",
      "endturn",
      "6/1",
      "e1k1",
      "j1k1",
      "endturn",
      "6/2",
      "endturn",
      "4/1",
      "h2d2",
      "d2c2",
      "endturn",
      "1/5",
      "s@h1",
      "s@l1",
      "endturn",
      "4/3",
      "a2d1",
      "f2c2",
      "endturn",
      "2/3",
      "h1f1",
      "g2j2",
      "endturn",
      "5/5",
      "g1l1",
      "g1l1",
      "e1j1",
      "e1j1",
      "endturn",
      "4/2",
      "s@i1",
      "g2i2",
      "endturn",
      "1/3",
      "d1e1",
      "a2c1",
      "endturn",
      "6/5",
      "a1f2",
      "f2k2",
      "endturn",
      "4/6",
      "e1i1",
      "c1i1",
      "endturn",
      "1/3",
      "endturn",
      "5/3",
      "c2c1",
      "c1f1",
      "endturn",
      "3/4",
      "endturn",
      "1/2",
      "f1h1",
      "h1i1",
      "endturn",
      "4/4",
      "endturn",
      "6/4",
      "c2d1",
      "a2d1",
      "endturn",
      "2/4",
      "endturn",
      "3/4",
      "a2c1",
      "c1g1",
      "endturn",
      "1/4",
      "endturn",
      "1/4",
      "d1h1",
      "h1i1",
      "endturn",
      "4/3",
      "endturn",
      "3/4",
      "d1g1",
      "g1k1",
      "endturn",
      "2/6",
      "endturn",
      "4/5",
      "g1k1",
      "g1l1",
      "endturn",
      "2/5",
      "s@h1",
      "endturn",
      "3/5",
      "g1j1",
      "g1l1",
      "endturn",
      "2/5",
      "s@h1",
      "endturn",
      "4/5",
      "^i1",
      "^i1",
      "endturn",
      "4/6",
      "s@g1",
      "h1d1",
      "endturn",
      "4/2",
      "^i1",
      "i1k1",
      "endturn",
      "1/6",
      "a1a2",
      "a2g2",
      "endturn",
      "6/2",
      "j1l1",
      "^j1",
      "endturn",
      "6/6",
      "h1b1",
      "d1c2",
      "c2i2",
      "g1a1",
      "endturn",
      "5/4"
    )
    "be valid game that generates valid lifts" in {
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.board.piecesCanLift(Player.P1) must_== true
        g.situation.board.playerPiecesOnBoardOrInPocket(Player.P1) must_== 11
        g.situation.board.history.score must_== Score(4, 0)
        g.situation.lifts.map(_.toUci.uci).toSet must_== Set("^j1")
      }
    }

    "be valid game that can handle a variety of lift scenarios" in {
      playActionStrs(actionStrs ::: List("^j1", "^k1")) must beValid.like { g =>
        g.situation.board.piecesCanLift(Player.P1) must_== true
        g.situation.board.playerPiecesOnBoardOrInPocket(Player.P1) must_== 9
        g.situation.board.history.score must_== Score(6, 0)
        g.situation.board.history.currentTurn.map(_.uci) must_== List("5/4", "^j1", "^k1")
      }
    }

    "be unchanged after undoing a lift action" in {
      playActionStrs(actionStrs ::: List("^j1", "undo")) must beValid.like { g =>
        val gamePreUndo = forceValidGameToGame(playActionStrs(actionStrs))
        g.actionStrs must_== gamePreUndo.actionStrs
        g.plies must_== gamePreUndo.plies
        g.turnCount must_== gamePreUndo.turnCount
        g.situation.player must_== gamePreUndo.situation.player
        g.situation.board.pieces must_== gamePreUndo.board.pieces
        g.situation.board.pocketData must_== gamePreUndo.board.pocketData
        g.situation.board.unusedDice.sorted must_== gamePreUndo.board.unusedDice.sorted
        g.situation.board.history.lastTurn must_== gamePreUndo.board.history.lastTurn
        g.situation.board.history.currentTurn must_== gamePreUndo.board.history.currentTurn
        g.situation.board.history.score must_== gamePreUndo.board.history.score
        g.situation.board.history.halfMoveClock must_== gamePreUndo.board.history.halfMoveClock
        g.situation.lifts.map(_.toUci.uci).toSet must_== gamePreUndo.situation.lifts.map(_.toUci.uci).toSet
        g.situation.board.piecesCanLift(Player.P1) must_== gamePreUndo.situation.board.piecesCanLift(
          Player.P1
        )
        g.situation.board.playerPiecesOnBoardOrInPocket(Player.P1) must_== gamePreUndo.situation.board
          .playerPiecesOnBoardOrInPocket(Player.P1)
      }
    }

    "be unchanged after undoing second lift action" in {
      playActionStrs(actionStrs ::: List("^j1", "^k1", "undo")) must beValid.like { g =>
        val gamePreUndo = forceValidGameToGame(playActionStrs(actionStrs ::: List("^j1")))
        g.actionStrs must_== gamePreUndo.actionStrs
        g.plies must_== gamePreUndo.plies
        g.turnCount must_== gamePreUndo.turnCount
        g.situation.player must_== gamePreUndo.situation.player
        g.situation.board.pieces must_== gamePreUndo.board.pieces
        g.situation.board.pocketData must_== gamePreUndo.board.pocketData
        g.situation.board.unusedDice.sorted must_== gamePreUndo.board.unusedDice.sorted
        g.situation.board.history.lastTurn must_== gamePreUndo.board.history.lastTurn
        g.situation.board.history.currentTurn must_== gamePreUndo.board.history.currentTurn
        g.situation.board.history.score must_== gamePreUndo.board.history.score
        g.situation.board.history.halfMoveClock must_== gamePreUndo.board.history.halfMoveClock
        g.situation.lifts.map(_.toUci.uci).toSet must_== gamePreUndo.situation.lifts.map(_.toUci.uci).toSet
        g.situation.board.piecesCanLift(Player.P1) must_== gamePreUndo.situation.board.piecesCanLift(
          Player.P1
        )
        g.situation.board.playerPiecesOnBoardOrInPocket(Player.P1) must_== gamePreUndo.situation.board
          .playerPiecesOnBoardOrInPocket(Player.P1)
      }
    }

    "be unchanged after undoing two lift actions" in {
      playActionStrs(actionStrs ::: List("^j1", "^k1", "undo", "undo")) must beValid.like { g =>
        val gamePreUndo = forceValidGameToGame(playActionStrs(actionStrs))
        g.actionStrs must_== gamePreUndo.actionStrs
        g.plies must_== gamePreUndo.plies
        g.turnCount must_== gamePreUndo.turnCount
        g.situation.player must_== gamePreUndo.situation.player
        g.situation.board.pieces must_== gamePreUndo.board.pieces
        g.situation.board.pocketData must_== gamePreUndo.board.pocketData
        g.situation.board.unusedDice.sorted must_== gamePreUndo.board.unusedDice.sorted
        g.situation.board.history.lastTurn must_== gamePreUndo.board.history.lastTurn
        g.situation.board.history.currentTurn must_== gamePreUndo.board.history.currentTurn
        g.situation.board.history.score must_== gamePreUndo.board.history.score
        g.situation.board.history.halfMoveClock must_== gamePreUndo.board.history.halfMoveClock
        g.situation.lifts.map(_.toUci.uci).toSet must_== gamePreUndo.situation.lifts.map(_.toUci.uci).toSet
        g.situation.board.piecesCanLift(Player.P1) must_== gamePreUndo.situation.board.piecesCanLift(
          Player.P1
        )
        g.situation.board.playerPiecesOnBoardOrInPocket(Player.P1) must_== gamePreUndo.situation.board
          .playerPiecesOnBoardOrInPocket(Player.P1)
      }
    }

  }

  "Backgammon Variant handles rule requiring highest dice to be used if both can't be used" should {
    "be valid game" in {
      val actionStrs = List(
        "3/4",
        "l2h2",
        "l2i2",
        "endturn",
        "5/4",
        "e2j2",
        "g2k2",
        "endturn",
        "5/1",
        "h2c2",
        "c2b2",
        "endturn",
        "2/5",
        "l1j1",
        "a1e2",
        "endturn",
        "4/5",
        "b2d1",
        "a2d1",
        "endturn",
        "6/2",
        "l1f1",
        "a1b2",
        "endturn",
        "6/1",
        "a2f1",
        "e1f1",
        "endturn",
        "2/4",
        "s@i1",
        "j1h1",
        "endturn",
        "6/5",
        "i2c2",
        "c2c1",
        "endturn",
        "3/5",
        "a1e2",
        "a1c2",
        "endturn",
        "4/6",
        "c1i1",
        "e1i1",
        "endturn",
        "4/2",
        "s@k1",
        "e2i2",
        "endturn",
        "6/1",
        "a2a1",
        "a2f1",
        "endturn",
        "6/4",
        "endturn",
        "5/4",
        "e1j1",
        "f1j1",
        "endturn",
        "6/1",
        "s@l1",
        "c2i2",
        "endturn",
        "4/4",
        "d1h1",
        "d1h1",
        "g1k1",
        "g1k1",
        "endturn",
        "2/1",
        "s@l1",
        "endturn",
        "3/3",
        "a2c1",
        "c1f1",
        "a1d1",
        "d1g1",
        "endturn",
        "1/3",
        "s@l1",
        "e2h2",
        "endturn",
        "3/3",
        "f1i1",
        "f1i1",
        "g1j1",
        "g1j1",
        "endturn",
        "5/5",
        "g2l2",
        "b2g2",
        "e2j2",
        "e2j2",
        "endturn",
        "1/5",
        "f1k1",
        "j1k1",
        "endturn",
        "5/1",
        "g2l2",
        "k2l2",
        "endturn",
        "4/3",
        "^i1",
        "^j1",
        "endturn",
        "2/2",
        "j2l2",
        "j2l2",
        "j2l2",
        "i2k2",
        "endturn",
        "2/2",
        "i1k1",
        "i1k1",
        "i1k1",
        "^k1",
        "endturn",
        "1/5",
        "g2l2",
        "k2l2",
        "endturn",
        "3/5",
        "^h1",
        "g1j1",
        "endturn",
        "3/2",
        "l1i1",
        "i1g1",
        "endturn",
        "5/2",
        "s@k2",
        "k2f2",
        "endturn",
        "5/5",
        "g1b1",
        "b1d2",
        "g2l2",
        "g2l2",
        "endturn",
        "4/2",
        "f2b2",
        "h1j1",
        "endturn",
        "4/4",
        "l1h1",
        "l1h1",
        "h1d1",
        "h1d1",
        "endturn",
        "1/1",
        "j1k1",
        "j1k1",
        "j1k1",
        "j1k1",
        "endturn",
        "6/2",
        "d2j2",
        "j2l2",
        "endturn",
        "3/2"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.canMove must_== true
        g.situation.actions.map(_.toUci.uci) must_== List("b2b1")
      }
    }
  }

  "Backgammon Variant handles restricted look ahead rules" should {
    "be valid game that forces use of dice for moves that enables both dice to be used" in {
      val actionStrs = List(
        "3/6",
        "a2f1",
        "e1h1",
        "endturn",
        "3/6",
        "a1f2",
        "a1c2",
        "endturn",
        "6/6",
        "a2f1",
        "a2f1",
        "a2f1",
        "a2f1",
        "endturn",
        "2/1",
        "c2e2",
        "e2f2",
        "endturn",
        "2/1",
        "e1g1",
        "g1h1",
        "endturn",
        "2/1",
        "g2h2",
        "h2j2",
        "endturn",
        "6/4"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        // cant use 4 on piece that is on e1 (e1i1)
        g.situation.moves.values.flatten.map(_.toUci.uci).toSet must_== Set(
          "l2h2",
          "e1k1",
          "f1j1",
          "g1k1"
        )
      }
    }

    "be valid game that forces use of dice for drops that enables both dice to be used" in {
      val actionStrs = List(
        "endturn",
        "3/1",
        "e2h2",
        "g2h2",
        "endturn",
        "5/3",
        "e1j1",
        "l2i2",
        "endturn",
        "4/4",
        "e2i2",
        "e2i2",
        "a1d2",
        "a1d2",
        "endturn",
        "3/1",
        "s@j2",
        "g1h1",
        "endturn",
        "1/6",
        "g2h2",
        "l1f1",
        "endturn",
        "5/5",
        "g1l1",
        "j2e2",
        "a2e1",
        "a2e1",
        "endturn",
        "1/2",
        "s@l1",
        "l1j1",
        "endturn",
        "6/5",
        "endturn",
        "5/1",
        "f1a1",
        "j1i1",
        "endturn",
        "5/3",
        "s@j2",
        "endturn",
        "2/4",
        "a1b2",
        "b2f2",
        "endturn",
        "1/3",
        "s@j2",
        "e1f1",
        "endturn",
        "3/1",
        "i1f1",
        "d2e2",
        "endturn",
        "1/3",
        "s@j2",
        "s@l2",
        "endturn",
        "5/4",
        "f2k2",
        "g2k2",
        "endturn",
        "2/5",
        "l2j2",
        "e1j1",
        "endturn",
        "4/1",
        "e2i2",
        "d2e2",
        "endturn",
        "6/6",
        "j2d2",
        "j2d2",
        "j2d2",
        "d2c1",
        "endturn",
        "1/3",
        "f1c1",
        "c1b1",
        "endturn",
        "6/6",
        "endturn",
        "5/2",
        "a1e2",
        "a1b2",
        "endturn",
        "4/2",
        "endturn",
        "2/5",
        "h2j2",
        "e2j2",
        "endturn",
        "1/5",
        "s@l2",
        "endturn",
        "6/4",
        "b2h2",
        "b1c2",
        "endturn",
        "2/6",
        "endturn",
        "3/6",
        "a1c2",
        "e2k2",
        "endturn",
        "6/3",
        "endturn",
        "5/6",
        "c2h2",
        "c2i2",
        "endturn",
        "4/3",
        "endturn",
        "6/4",
        "^g2",
        "g2k2",
        "endturn",
        "3/5",
        "endturn",
        "3/1",
        "h2k2",
        "i2j2",
        "endturn",
        "4/5",
        "endturn",
        "1/4",
        "^i2",
        "h2i2",
        "endturn",
        "2/4",
        "endturn",
        "5/6",
        "^h2",
        "^h2",
        "endturn",
        "6/4",
        "s@g2",
        "l2h2",
        "endturn",
        "4/5",
        "^i2",
        "^i2",
        "endturn",
        "5/3",
        "e1j1",
        "l2i2",
        "endturn",
        "4/2"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        // forced to use 4 and not 2
        g.situation.dropsAsDrops.size must_== 1
        g.situation.dropsAsDrops.map(_.toUci.uci).toSet must_== Set("s@i1")
      }
    }

    // https://playstrategy.dev/lOx6ysxb
    "be valid game that forces use of max dice when either can be used but not both" in {
      val actionStrs = List(
        "endturn",
        "4/2",
        "g2i2",
        "e2i2",
        "endturn",
        "1/3",
        "e1h1",
        "g1h1",
        "endturn",
        "1/5",
        "g2h2",
        "a1e2",
        "endturn",
        "2/1",
        "k2j2",
        "j2h2",
        "endturn",
        "5/2",
        "s@k1",
        "a1e2",
        "endturn",
        "5/4",
        "l2h2",
        "a2e1",
        "endturn",
        "2/4",
        "i2k2",
        "e2i2",
        "endturn",
        "6/2",
        "s@k2",
        "l2f2",
        "endturn",
        "4/6",
        "s@i1",
        "a1f2",
        "endturn",
        "4/6",
        "endturn",
        "2/6",
        "k1i1",
        "e2k2",
        "endturn",
        "6/6",
        "endturn",
        "3/6",
        "f2i2",
        "e2k2",
        "endturn",
        "5/1",
        "s@h2",
        "s@l2",
        "endturn",
        "1/2",
        "e2f2",
        "a1b2",
        "endturn",
        "5/2",
        "h2f2",
        "a2e1",
        "endturn",
        "5/6",
        "endturn",
        "4/1",
        "f2b2",
        "b2a2",
        "endturn",
        "6/6",
        "endturn",
        "6/6",
        "a2f1",
        "a2f1",
        "l2f2",
        "a2f1",
        "endturn",
        "3/6",
        "s@j1",
        "endturn",
        "2/4",
        "f2b2",
        "b2a1",
        "endturn",
        "5/4",
        "s@i1",
        "i1d1",
        "endturn",
        "4/1",
        "a1e1",
        "e1f1",
        "endturn",
        "2/1",
        "k1j1",
        "k1i1",
        "endturn",
        "3/5",
        "h2c2",
        "c2a1",
        "endturn",
        "6/1",
        "j1d1",
        "g2h2",
        "endturn",
        "2/3",
        "s@j2",
        "j2h2",
        "endturn",
        "2/1",
        "s@k1",
        "g2h2",
        "endturn",
        "3/4",
        "s@j2",
        "f1j1",
        "endturn",
        "4/5",
        "s@i1",
        "i1d1",
        "endturn",
        "6/5",
        "e1j1",
        "a1g1",
        "endturn",
        "2/5",
        "h2j2",
        "i1d1",
        "endturn",
        "1/2",
        "s@l2",
        "l2j2",
        "endturn",
        "2/6",
        "s@k1",
        "d1c2",
        "endturn",
        "5/4",
        "j2e2",
        "e2a2",
        "endturn",
        "2/1",
        "c2d2",
        "d2f2",
        "endturn",
        "4/6",
        "a2f1",
        "f1j1",
        "endturn",
        "2/1",
        "f2h2",
        "h2i2",
        "endturn",
        "4/4",
        "f1j1",
        "f1j1",
        "f1j1",
        "endturn",
        "3/4",
        "d1a1",
        "a1d2",
        "endturn",
        "5/5",
        "e1j1",
        "e1j1",
        "e1j1",
        "^h1",
        "endturn",
        "3/5",
        "d2i2",
        "k1h1",
        "endturn",
        "5/4",
        "s@h2",
        "h2d2",
        "endturn",
        "6/3",
        "k1e1",
        "h1e1",
        "endturn",
        "5/6",
        "d2c1",
        "c1h1",
        "endturn",
        "5/2",
        "d1b2",
        "b2d2",
        "endturn",
        "2/3",
        "h1k1",
        "^k1",
        "endturn",
        "4/6",
        "d2h2",
        "d1c2",
        "endturn",
        "6/4",
        "^g1",
        "g1k1",
        "endturn",
        "1/3",
        "l1i1",
        "l1k1",
        "endturn",
        "4/2",
        "endturn",
        "4/4",
        "c2g2",
        "g2k2",
        "i1e1",
        "h2l2",
        "endturn",
        "2/2",
        "endturn",
        "3/6",
        "i2l2",
        "k1e1",
        "endturn",
        "5/6",
        "s@g2",
        "g2b2",
        "endturn",
        "1/4",
        "k2l2",
        "e1a1",
        "endturn",
        "1/2",
        "b2a1",
        "a1b1",
        "endturn",
        "4/1",
        "s@i1",
        "e1d1",
        "endturn",
        "2/4",
        "b1d1",
        "d1h1",
        "endturn",
        "2/1",
        "s@k1",
        "i1h1",
        "endturn",
        "5/2",
        "s@h2",
        "h2f2",
        "endturn",
        "5/1",
        "k1f1",
        "f1e1",
        "endturn",
        "6/4",
        "f2a1",
        "g1k1",
        "endturn",
        "3/4",
        "h1d1",
        "d1a1",
        "endturn",
        "2/5",
        "s@h2",
        "h2f2",
        "endturn",
        "3/3",
        "a1c2",
        "c2f2",
        "i2l2",
        "f2i2",
        "endturn",
        "2/1",
        "endturn",
        "6/1",
        "e1d1",
        "d1c2",
        "endturn",
        "2/1",
        "endturn",
        "3/6",
        "c2i2",
        "i2l2",
        "endturn",
        "3/4",
        "s@j2",
        "g1k1",
        "endturn",
        "2/3",
        "i2l2",
        "i2k2",
        "endturn",
        "1/5",
        "j2e2",
        "j1k1",
        "endturn",
        "1/2",
        "i2k2",
        "i2j2",
        "endturn",
        "6/3"
      )
      playActionStrs(actionStrs, Some(Game.apply(variant.Nackgammon))) must beValid.like { g =>
        g.situation.moves.values.flatten.map(_.toUci.uci).toSet must_== Set("e2b1")
      }
    }

    // https://playstrategy.dev/3gZCwBU6
    "be valid game that forces use of max dice when lifts involved" in {
      val actionStrs = List(
        "4/6",
        "e1k1",
        "g1k1",
        "endturn",
        "4/5",
        "a1e2",
        "a1d2",
        "endturn",
        "3/6",
        "a2f1",
        "a2c1",
        "endturn",
        "6/5",
        "l1f1",
        "f1a1",
        "endturn",
        "2/1",
        "s@k2",
        "k2j2",
        "endturn",
        "5/3",
        "e2j2",
        "g2j2",
        "endturn",
        "3/1",
        "s@l2",
        "c1f1",
        "endturn",
        "3/3",
        "l1i1",
        "i1f1",
        "e2h2",
        "e2h2",
        "endturn",
        "5/3",
        "endturn",
        "4/6",
        "e2k2",
        "g2k2",
        "endturn",
        "3/4",
        "s@i2",
        "l2i2",
        "endturn",
        "3/2",
        "f1c1",
        "c1a1",
        "endturn",
        "1/6",
        "a2f1",
        "e1f1",
        "endturn",
        "5/3",
        "d2g2",
        "a1e2",
        "endturn",
        "3/5",
        "i2d2",
        "d2a2",
        "endturn",
        "1/4",
        "e2i2",
        "g2h2",
        "endturn",
        "2/2",
        "endturn",
        "1/4",
        "a1d2",
        "h2i2",
        "endturn",
        "4/2",
        "endturn",
        "6/2",
        "a1f2",
        "d2f2",
        "endturn",
        "2/2",
        "endturn",
        "2/1",
        "a1b2",
        "b2c2",
        "endturn",
        "5/1",
        "s@l2",
        "a2e1",
        "endturn",
        "2/4",
        "a1d2",
        "d2f2",
        "endturn",
        "3/1",
        "e1h1",
        "g1h1",
        "endturn",
        "3/3",
        "f2i2",
        "c2f2",
        "f2i2",
        "g2j2",
        "endturn",
        "2/4",
        "e1i1",
        "g1i1",
        "endturn",
        "5/5",
        "f2k2",
        "f2k2",
        "^h2",
        "^h2",
        "endturn",
        "4/6",
        "a2f1",
        "a2d1",
        "endturn",
        "1/1",
        "g2h2",
        "i2j2",
        "j2k2",
        "i2j2",
        "endturn",
        "3/6",
        "d1j1",
        "f1i1",
        "endturn",
        "5/4",
        "^h2",
        "^i2",
        "endturn",
        "2/2",
        "f1h1",
        "h1j1",
        "i1k1",
        "f1h1",
        "endturn",
        "2/3",
        "^j2",
        "^k2",
        "endturn",
        "1/2",
        "k1l1",
        "h1j1",
        "endturn",
        "2/5"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.moves.values.flatten.map(_.toUci.uci).toSet must_== Set("g2i2")
        g.situation.lifts.isEmpty must_== true
      }
    }
  }

  "Backgammon Variant has different win statuses" should {
    "be valid game that ends in a GammonWin when 15-0 and no pieces in opponents home" in {
      val actionStrs = List(
        "4/5",
        "l2h2",
        "a2e1",
        "endturn",
        "4/2",
        "l1h1",
        "l1j1",
        "endturn",
        "5/6",
        "e1j1",
        "l2f2",
        "endturn",
        "4/2",
        "s@k1",
        "a1d2",
        "endturn",
        "6/1",
        "e1k1",
        "j1k1",
        "endturn",
        "6/2",
        "endturn",
        "4/1",
        "h2d2",
        "d2c2",
        "endturn",
        "1/5",
        "s@h1",
        "s@l1",
        "endturn",
        "4/3",
        "a2d1",
        "f2c2",
        "endturn",
        "2/3",
        "h1f1",
        "g2j2",
        "endturn",
        "5/5",
        "g1l1",
        "g1l1",
        "e1j1",
        "e1j1",
        "endturn",
        "4/2",
        "s@i1",
        "g2i2",
        "endturn",
        "1/3",
        "d1e1",
        "a2c1",
        "endturn",
        "6/5",
        "a1f2",
        "f2k2",
        "endturn",
        "4/6",
        "e1i1",
        "c1i1",
        "endturn",
        "1/3",
        "endturn",
        "5/3",
        "c2c1",
        "c1f1",
        "endturn",
        "3/4",
        "endturn",
        "1/2",
        "f1h1",
        "h1i1",
        "endturn",
        "4/4",
        "endturn",
        "6/4",
        "c2d1",
        "a2d1",
        "endturn",
        "2/4",
        "endturn",
        "3/4",
        "a2c1",
        "c1g1",
        "endturn",
        "1/4",
        "endturn",
        "1/4",
        "d1h1",
        "h1i1",
        "endturn",
        "4/3",
        "endturn",
        "3/4",
        "d1g1",
        "g1k1",
        "endturn",
        "2/6",
        "endturn",
        "4/5",
        "g1k1",
        "g1l1",
        "endturn",
        "2/5",
        "s@h1",
        "endturn",
        "3/5",
        "g1j1",
        "g1l1",
        "endturn",
        "2/5",
        "s@h1",
        "endturn",
        "4/5",
        "^i1",
        "^i1",
        "endturn",
        "4/6",
        "s@g1",
        "h1d1",
        "endturn",
        "4/2",
        "^i1",
        "i1k1",
        "endturn",
        "1/6",
        "a1a2",
        "a2g2",
        "endturn",
        "6/2",
        "j1l1",
        "^j1",
        "endturn",
        "6/6",
        "h1b1",
        "d1c2",
        "c2i2",
        "g1a1",
        "endturn",
        "5/4",
        "^j1",
        "^k1",
        "endturn",
        "4/4",
        "b1c2",
        "c2g2",
        "a1d2",
        "a1d2",
        "endturn",
        "6/4",
        "^k1",
        "^k1",
        "endturn",
        "3/1",
        "d2g2",
        "a1a2",
        "endturn",
        "3/2",
        "^k1",
        "^k1",
        "endturn",
        "5/2",
        "d2i2",
        "e2g2",
        "endturn",
        "6/3",
        "^l1",
        "^l1",
        "endturn",
        "3/4",
        "a2d2",
        "d2h2",
        "endturn",
        "4/6",
        "^l1",
        "^l1",
        "endturn",
        "3/6",
        "e2h2",
        "e2k2",
        "endturn",
        "4/1",
        "^l1"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.board.history.score must_== Score(15, 0)
        g.situation.end must_== true
        g.situation.board.pieceInOpponentsHome(Player.P2) must_== false
        g.situation.winner must_== Some(Player.P1)
        g.situation.status must_== Some(Status.GammonWin)
      }
    }

    "be valid game that ends in a StandardWin when both sides score" in {
      val actionStrs = List(
        "endturn",
        "3/1",
        "e2h2",
        "g2h2",
        "endturn",
        "5/3",
        "e1j1",
        "l2i2",
        "endturn",
        "4/4",
        "e2i2",
        "e2i2",
        "a1d2",
        "a1d2",
        "endturn",
        "3/1",
        "s@j2",
        "g1h1",
        "endturn",
        "1/6",
        "g2h2",
        "l1f1",
        "endturn",
        "5/5",
        "g1l1",
        "j2e2",
        "a2e1",
        "a2e1",
        "endturn",
        "1/2",
        "s@l1",
        "l1j1",
        "endturn",
        "6/5",
        "endturn",
        "5/1",
        "f1a1",
        "j1i1",
        "endturn",
        "5/3",
        "s@j2",
        "endturn",
        "2/4",
        "a1b2",
        "b2f2",
        "endturn",
        "1/3",
        "s@j2",
        "e1f1",
        "endturn",
        "3/1",
        "i1f1",
        "d2e2",
        "endturn",
        "1/3",
        "s@j2",
        "s@l2",
        "endturn",
        "5/4",
        "f2k2",
        "g2k2",
        "endturn",
        "2/5",
        "l2j2",
        "e1j1",
        "endturn",
        "4/1",
        "e2i2",
        "d2e2",
        "endturn",
        "6/6",
        "j2d2",
        "j2d2",
        "j2d2",
        "d2c1",
        "endturn",
        "1/3",
        "f1c1",
        "c1b1",
        "endturn",
        "6/6",
        "endturn",
        "5/2",
        "a1e2",
        "a1b2",
        "endturn",
        "4/2",
        "endturn",
        "2/5",
        "h2j2",
        "e2j2",
        "endturn",
        "1/5",
        "s@l2",
        "endturn",
        "6/4",
        "b2h2",
        "b1c2",
        "endturn",
        "2/6",
        "endturn",
        "3/6",
        "a1c2",
        "e2k2",
        "endturn",
        "6/3",
        "endturn",
        "5/6",
        "c2h2",
        "c2i2",
        "endturn",
        "4/3",
        "endturn",
        "6/4",
        "^g2",
        "g2k2",
        "endturn",
        "3/5",
        "endturn",
        "3/1",
        "h2k2",
        "i2j2",
        "endturn",
        "4/5",
        "endturn",
        "1/4",
        "^i2",
        "h2i2",
        "endturn",
        "2/4",
        "endturn",
        "5/6",
        "^h2",
        "^h2",
        "endturn",
        "6/4",
        "s@g2",
        "l2h2",
        "endturn",
        "4/5",
        "^i2",
        "^i2",
        "endturn",
        "5/3",
        "e1j1",
        "l2i2",
        "endturn",
        "4/2",
        "s@i1",
        "j2l2",
        "endturn",
        "6/4",
        "e1i1",
        "h2b2",
        "endturn",
        "6/6",
        "endturn",
        "1/1",
        "g1h1",
        "h1i1",
        "a2a1",
        "a2a1",
        "endturn",
        "5/3",
        "s@h1",
        "h1e1",
        "endturn",
        "6/2",
        "s@g2",
        "d2b2",
        "endturn",
        "1/6",
        "e1d1",
        "d1c2",
        "endturn",
        "2/2",
        "g2e2",
        "e2c2",
        "a1c1",
        "a1c1",
        "endturn",
        "2/6",
        "s@k1",
        "k1e1",
        "endturn",
        "1/5",
        "a2e1",
        "g2f2",
        "endturn",
        "4/6",
        "endturn",
        "1/4",
        "b2a2",
        "b2c1",
        "endturn",
        "1/1",
        "s@l1",
        "k2l2",
        "l1k1",
        "k2l2",
        "endturn",
        "1/6",
        "e1k1",
        "c1d1",
        "endturn",
        "6/4",
        "endturn",
        "6/4",
        "a2f1",
        "f1j1",
        "endturn",
        "1/5",
        "s@h1",
        "k2l2",
        "endturn",
        "3/5",
        "c1h1",
        "h1k1",
        "endturn",
        "4/6",
        "endturn",
        "4/4",
        "c2b1",
        "d2a1",
        "f2b2",
        "b2c1",
        "endturn",
        "3/6",
        "endturn",
        "5/4",
        "c1h1",
        "d1h1",
        "endturn",
        "5/1",
        "s@l1",
        "endturn",
        "2/1",
        "a1c1",
        "i2h2",
        "endturn",
        "5/5",
        "endturn",
        "2/5",
        "h2f2",
        "b1g1",
        "endturn",
        "2/6",
        "l1f1",
        "f1d1",
        "endturn",
        "1/1",
        "c1d1",
        "c1d1",
        "f2e2",
        "e2d2",
        "endturn",
        "5/1",
        "s@l1",
        "endturn",
        "1/1",
        "d1e1",
        "d1e1",
        "e1f1",
        "e1f1",
        "endturn",
        "3/3",
        "endturn",
        "1/4",
        "d2c2",
        "c2b1",
        "endturn",
        "4/5",
        "endturn",
        "2/4",
        "b1d1",
        "d1h1",
        "endturn",
        "2/4",
        "j2l2",
        "endturn",
        "2/3",
        "f1h1",
        "f1i1",
        "endturn",
        "1/4",
        "j2k2",
        "endturn",
        "6/3",
        "^g1",
        "^j1",
        "endturn",
        "4/3",
        "endturn",
        "1/6",
        "g1h1",
        "^g1",
        "endturn",
        "3/4",
        "endturn",
        "6/3",
        "^h1",
        "i1l1",
        "endturn",
        "4/2",
        "endturn",
        "1/5",
        "^l1",
        "^h1",
        "endturn",
        "6/2",
        "s@g1",
        "g1e1",
        "endturn",
        "6/1",
        "^h1",
        "k1l1",
        "endturn",
        "2/3",
        "e1c1",
        "c1a2",
        "endturn",
        "1/4",
        "^l1",
        "^i1",
        "endturn",
        "1/5",
        "a2b2",
        "b2g2",
        "endturn",
        "5/6",
        "^h1",
        "^h1",
        "endturn",
        "3/6",
        "^g2",
        "^k2",
        "endturn",
        "1/4",
        "k1l1",
        "^i1",
        "endturn",
        "6/3",
        "^k2",
        "^k2",
        "endturn",
        "4/1",
        "^j1",
        "^l1",
        "endturn",
        "3/6",
        "^l2",
        "^l2",
        "endturn",
        "5/3",
        "^j1"
      )
      playActionStrs(actionStrs.dropRight(1)) must beValid.like { g =>
        g.situation.board.history.score must_== Score(14, 12)
        g.situation.end must_== false
        g.situation.winner must_== None
        g.situation.status must_== None
        g.situation.board.racePosition must_== true
        g.situation.board.pipCount(Player.P1) must_== 3
        g.situation.maxTurnsFromEnd(Player.P1) must_== Some(1)
        g.situation.minTurnsFromEnd(Player.P1) must_== Some(1)
        g.situation.board.pipCount(Player.P2) must_== 3
        g.situation.maxTurnsFromEnd(Player.P2) must_== Some(2)
        g.situation.minTurnsFromEnd(Player.P2) must_== Some(1)
      }
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.board.history.score must_== Score(15, 12)
        g.situation.end must_== true
        g.situation.winner must_== Some(Player.P1)
        g.situation.status must_== Some(Status.SingleWin)
        g.situation.board.pipCount(Player.P1) must_== 0
      }
    }

    "be valid game that ends in a BackgammonWin when one side has pieces in opponent home" in {
      val actionStrs = List(
        "endturn",
        "5/1",
        "a1e2",
        "l1k1",
        "endturn",
        "6/5",
        "a2f1",
        "f1k1",
        "endturn",
        "1/2",
        "s@k1",
        "l1k1",
        "endturn",
        "3/4",
        "s@j2",
        "j2f2",
        "endturn",
        "1/6",
        "a1f2",
        "e2f2",
        "endturn",
        "2/6",
        "s@k2",
        "a2f1",
        "endturn",
        "3/2",
        "k1h1",
        "h1f1",
        "endturn",
        "6/4",
        "s@i2",
        "a2f1",
        "endturn",
        "4/1",
        "s@i1",
        "i1h1",
        "endturn",
        "2/2",
        "k2i2",
        "f1h1",
        "g1i1",
        "i1k1",
        "endturn",
        "1/4",
        "s@i1",
        "s@l1",
        "endturn",
        "1/6",
        "h1i1",
        "e1k1",
        "endturn",
        "4/3",
        "s@i1",
        "l1i1",
        "endturn",
        "1/3",
        "s@l2",
        "l2i2",
        "endturn",
        "6/1",
        "a1f2",
        "i1h1",
        "endturn",
        "5/3",
        "e1j1",
        "e1h1",
        "endturn",
        "6/1",
        "s@l1",
        "i1c1",
        "endturn",
        "2/3",
        "h1j1",
        "a2c1",
        "endturn",
        "2/5",
        "s@h1",
        "h1f1",
        "endturn",
        "2/1",
        "c1d1",
        "d1f1",
        "endturn",
        "1/1",
        "s@l1",
        "g2h2",
        "g2h2",
        "a1a2",
        "endturn",
        "4/3",
        "s@i2",
        "f1i1",
        "endturn",
        "3/4",
        "l1h1",
        "l1i1",
        "endturn",
        "6/2",
        "s@k2",
        "i2c2",
        "endturn",
        "6/6",
        "e2k2",
        "e2k2",
        "h1b1",
        "b1e2",
        "endturn",
        "5/2",
        "endturn",
        "1/4",
        "i1e1",
        "a1a2",
        "endturn",
        "2/1",
        "s@l2",
        "l2j2",
        "endturn",
        "5/4",
        "e2j2",
        "f2j2",
        "endturn",
        "6/2",
        "endturn",
        "3/2",
        "a2c2",
        "e1b1",
        "endturn",
        "5/3",
        "endturn",
        "3/1",
        "a2d2",
        "d2e2",
        "endturn",
        "5/1",
        "s@l2",
        "endturn",
        "1/5",
        "b1d2",
        "c2d2",
        "endturn",
        "4/1",
        "s@l2",
        "g1k1",
        "endturn",
        "3/5",
        "e2j2",
        "e2h2",
        "endturn",
        "3/3",
        "l2i2",
        "g1j1",
        "g1j1",
        "g1j1",
        "endturn",
        "4/3",
        "d2h2",
        "d2g2",
        "endturn",
        "5/5",
        "i2d2",
        "d2b1",
        "i2d2",
        "d2b1",
        "endturn",
        "5/3",
        "h2k2",
        "f2k2",
        "endturn",
        "2/3",
        "i2f2",
        "f2d2",
        "endturn",
        "5/4",
        "s@h1",
        "h1d1",
        "endturn",
        "3/6",
        "l2i2",
        "d2c1",
        "endturn",
        "6/2",
        "d1c2",
        "c2e2",
        "endturn",
        "1/3",
        "i2f2",
        "f2e2",
        "endturn",
        "4/2",
        "s@i1",
        "i1g1",
        "endturn",
        "4/6",
        "c1g1",
        "e2b1",
        "endturn",
        "1/2",
        "s@l1",
        "g2i2",
        "endturn",
        "6/5",
        "endturn",
        "1/5",
        "h2i2",
        "l1g1",
        "endturn",
        "4/3",
        "endturn",
        "2/3",
        "g1d1",
        "g2i2",
        "endturn",
        "5/3",
        "endturn",
        "6/1",
        "d1c2",
        "c2d2",
        "endturn",
        "1/3",
        "s@l2",
        "endturn",
        "3/2",
        "d2g2",
        "g2i2",
        "endturn",
        "5/5",
        "endturn",
        "4/4",
        "^i2",
        "^i2",
        "^i2",
        "^i2",
        "endturn",
        "1/1",
        "s@l2",
        "j1k1",
        "k1l1",
        "k1l1",
        "endturn",
        "6/1",
        "^g2",
        "g2h2",
        "endturn",
        "4/5",
        "b1g1",
        "g1k1",
        "endturn",
        "5/1",
        "^h2",
        "j2k2",
        "endturn",
        "3/2",
        "l2i2",
        "i2g2",
        "endturn",
        "6/3",
        "^h2",
        "h2k2",
        "endturn",
        "2/2",
        "b1d1",
        "b1d1",
        "d1f1",
        "d1f1",
        "endturn",
        "5/5",
        "^j2",
        "^j2",
        "^k2",
        "^k2",
        "endturn",
        "4/1",
        "l2h2",
        "h2g2",
        "endturn",
        "1/5",
        "^k2",
        "endturn",
        "6/4",
        "f1l1",
        "f1j1",
        "endturn",
        "6/6",
        "^k2",
        "^k2",
        "^k2"
      )
      playActionStrs(actionStrs.dropRight(1)) must beValid.like { g =>
        g.situation.board.history.score must_== Score(0, 14)
        g.situation.end must_== false
        g.situation.winner must_== None
        g.situation.status must_== None
      }
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.board.history.score must_== Score(0, 15)
        g.situation.end must_== true
        g.situation.winner must_== Some(Player.P2)
        g.situation.status must_== Some(Status.BackgammonWin)
        g.situation.board.pieceInOpponentsHome(Player.P1) must_== true
      }
    }
  }

  "Backgammon Variant handles forced actions" should {
    "have forced actions when two pieces on the bar" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "endturn",
        "2/3"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.board.pieceCountOnBar(Player.P1) must_== 2
        g.situation.canOnlyDrop must_== true
        g.situation.dropsAsDrops.size must_== 2
        g.situation.forcedAction.nonEmpty must_== true
      }
    }

    "have forced actions when one dice left and one piece on the bar" in {
      val actionStrs = List(
        "1/5",
        "l2k2",
        "e1j1",
        "endturn",
        "2/4",
        "l1j1",
        "g2k2",
        "endturn",
        "2/3",
        "s@k2"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.board.pieceCountOnBar(Player.P1) must_== 1
        g.situation.canOnlyDrop must_== true
        g.situation.dropsAsDrops.size must_== 1
        g.situation.forcedAction.nonEmpty must_== true
      }
    }

    "evaluate 'forced pair' actions correctly" in {
      val actionStrs = List(
        "3/5",
        "e1j1",
        "e1h1",
        "endturn",
        "4/3",
        "l1h1",
        "h1e1",
        "endturn",
        "4/3",
        "s@i2",
        "s@j2",
        "endturn",
        "1/2",
        "g2i2",
        "i2j2",
        "endturn",
        "6/3",
        "s@j2",
        "endturn",
        "2/6",
        "s@k1",
        "a1f2",
        "endturn",
        "3/4",
        "s@j2",
        "j2f2",
        "endturn",
        "2/6",
        "s@k1",
        "a1f2",
        "endturn",
        "4/2",
        "s@k2",
        "j2f2",
        "endturn",
        "1/6",
        "s@l1",
        "a1f2",
        "endturn",
        "5/6",
        "s@h2",
        "l2f2",
        "endturn",
        "2/4",
        "s@i1",
        "a1b2",
        "endturn",
        "6/3",
        "f2a1",
        "a2c1",
        "endturn",
        "6/3",
        "s@j1",
        "b2h2",
        "endturn",
        "5/4",
        "s@h2",
        "s@i2",
        "endturn",
        "4/6",
        "s@i1",
        "i1c1",
        "endturn",
        "6/2",
        "s@k2",
        "a2f1",
        "endturn",
        "6/1",
        "l1f1",
        "g2h2",
        "endturn",
        "5/6",
        "s@h2",
        "endturn",
        "5/3",
        "s@j1",
        "f1a1",
        "endturn",
        "4/2",
        "s@i2",
        "s@k2",
        "endturn",
        "4/6",
        "j1d1",
        "j1f1",
        "endturn",
        "1/5",
        "a2e1",
        "a2a1",
        "endturn",
        "4/1",
        "s@i1",
        "s@l1",
        "endturn",
        "4/6",
        "a2f1",
        "h2d2",
        "endturn",
        "6/1",
        "s@l1",
        "c1d2",
        "endturn",
        "2/2",
        "s@k2",
        "l2j2",
        "j2h2",
        "h2f2",
        "endturn",
        "3/3",
        "d1a1",
        "a1c2",
        "c2f2",
        "i1f1",
        "endturn",
        "3/5",
        "s@j2",
        "s@h2",
        "endturn",
        "1/4",
        "d2h2",
        "f1e1",
        "endturn",
        "1/3",
        "s@l2",
        "s@j2",
        "endturn",
        "3/6",
        "f2l2",
        "i1f1",
        "endturn",
        "1/6",
        "s@l2",
        "endturn",
        "3/3",
        "s@j1",
        "l1i1",
        "e1b1",
        "f1c1",
        "endturn",
        "3/4",
        "s@j2",
        "l2h2",
        "endturn",
        "5/2",
        "s@h1",
        "h1f1",
        "endturn",
        "2/2",
        "g1i1",
        "j2h2",
        "h2f2",
        "f2d2",
        "endturn",
        "3/2",
        "s@j1",
        "k1i1",
        "endturn",
        "3/2",
        "s@j2",
        "d2b2",
        "endturn",
        "1/1",
        "g2h2",
        "b1a1",
        "a1a2",
        "a2b2",
        "endturn",
        "1/2",
        "s@l2",
        "s@k2",
        "endturn",
        "6/2",
        "j1d1",
        "b2d2",
        "endturn",
        "2/5",
        "i2d2",
        "j2h2",
        "endturn",
        "6/4",
        "s@i1",
        "endturn",
        "4/2",
        "g1k1",
        "d2b2",
        "endturn",
        "1/1",
        "s@l1",
        "s@l1",
        "l1k1",
        "g2h2",
        "endturn",
        "3/4",
        "s@j2",
        "s@i2",
        "endturn",
        "1/5",
        "g2l2",
        "e2f2",
        "endturn",
        "4/2",
        "s@k2",
        "g1k1",
        "endturn",
        "6/1",
        "s@l1",
        "f2l2",
        "endturn",
        "3/6",
        "k2h2",
        "h2b2",
        "endturn",
        "5/2",
        "s@k1",
        "k1f1",
        "endturn",
        "4/3",
        "s@j2",
        "b2c1",
        "endturn",
        "5/5",
        "s@h1",
        "d1b2",
        "h1c1",
        "j1e1",
        "endturn",
        "4/1",
        "s@i2",
        "endturn",
        "4/6",
        "e1b2",
        "c1b2",
        "endturn",
        "3/5",
        "s@h2",
        "k2h2",
        "endturn",
        "6/6",
        "f1a2",
        "f1a2",
        "l1f1",
        "l1f1",
        "endturn",
        "6/4",
        "j2d2",
        "h2d2",
        "endturn",
        "4/6",
        "l1f1",
        "l1h1",
        "endturn",
        "2/6",
        "h2f2",
        "f2a1",
        "endturn",
        "6/6",
        "h1b1",
        "b1e2",
        "a2g2",
        "a2g2",
        "endturn",
        "5/4",
        "i2d2",
        "d2a1",
        "endturn",
        "3/5",
        "f1c1",
        "c1c2",
        "endturn",
        "6/1",
        "i2c2",
        "i2h2",
        "endturn",
        "3/6",
        "s@j1",
        "j1d1",
        "endturn",
        "1/3",
        "c2a1",
        "j2i2",
        "endturn",
        "4/5",
        "d1b2",
        "i1e1",
        "endturn",
        "5/5",
        "i2d2",
        "d2b1",
        "d2b1",
        "d2b1",
        "endturn",
        "4/1",
        "i1e1",
        "b2c2",
        "endturn",
        "3/5",
        "k2f2",
        "f2c2",
        "endturn",
        "4/5",
        "s@h1",
        "h1d1",
        "endturn",
        "3/1",
        "a1d1",
        "k2j2",
        "endturn",
        "2/1",
        "s@k1",
        "e1d1",
        "endturn",
        "4/2",
        "s@i2",
        "b1d1",
        "endturn",
        "6/4",
        "s@i1",
        "k1e1",
        "endturn",
        "1/4",
        "c2b1",
        "j2i2",
        "endturn",
        "5/1",
        "e1a2",
        "e1d1",
        "endturn",
        "2/1",
        "s@k2",
        "k2j2",
        "endturn",
        "1/5",
        "i1d1",
        "a2b2",
        "endturn",
        "6/3",
        "i2c2",
        "c2a1",
        "endturn",
        "4/6",
        "f1a2",
        "d1a2",
        "endturn",
        "6/2",
        "i2c2",
        "h2f2",
        "endturn",
        "1/4",
        "b2f2",
        "e2f2",
        "endturn",
        "3/4",
        "s@i2",
        "c2a1",
        "endturn",
        "5/2",
        "d1b2",
        "f1d1",
        "endturn",
        "6/5",
        "j2d2",
        "i2d2",
        "endturn",
        "5/1",
        "d1b2",
        "a2b2",
        "endturn",
        "2/2",
        "a1c1",
        "a1c1",
        "b1d1",
        "b1d1",
        "endturn",
        "3/2",
        "a2c2",
        "c2f2",
        "endturn",
        "4/3",
        "b1f1",
        "c1f1",
        "endturn",
        "2/6",
        "b2h2",
        "f2h2",
        "endturn",
        "4/5",
        "c1h1",
        "d1h1",
        "endturn",
        "1/3",
        "b2e2",
        "e2f2",
        "endturn",
        "5/1",
        "d2b1",
        "d2c2",
        "endturn",
        "6/5",
        "b2h2",
        "b2g2",
        "endturn",
        "2/6",
        "c2d1",
        "b1d1",
        "endturn",
        "4/1",
        "h2l2",
        "g2h2",
        "endturn",
        "3/1",
        "d1g1",
        "d1e1",
        "endturn",
        "2/3",
        "e2h2",
        "e2g2",
        "endturn",
        "3/5",
        "d1i1",
        "f1i1",
        "endturn",
        "1/4",
        "h2l2",
        "f2g2",
        "endturn",
        "3/4",
        "a1e1",
        "a1d1",
        "endturn",
        "3/1",
        "b2e2",
        "e2f2",
        "endturn",
        "2/5",
        "d1i1",
        "f1h1",
        "endturn",
        "1/4",
        "b2f2",
        "g2h2",
        "endturn",
        "5/4",
        "g1l1",
        "h1l1",
        "endturn",
        "3/6",
        "f2i2",
        "f2l2",
        "endturn",
        "3/3",
        "e1h1",
        "e1h1",
        "h1k1",
        "h1k1",
        "endturn",
        "4/1",
        "h2l2",
        "h2i2",
        "endturn",
        "5/6",
        "j2d2",
        "j2e2",
        "endturn",
        "4/4",
        "f2j2",
        "f2j2",
        "^i2",
        "^i2",
        "endturn",
        "1/3",
        "e2b2",
        "d2c2",
        "endturn",
        "5/1",
        "^h2",
        "h2i2",
        "endturn",
        "4/1",
        "c2b1",
        "b2a2",
        "endturn",
        "3/4",
        "^i2",
        "^j2",
        "endturn",
        "1/4",
        "b1f1",
        "k2j2",
        "endturn",
        "2/4",
        "endturn",
        "6/5",
        "j2d2",
        "k2f2",
        "endturn",
        "5/6",
        "endturn",
        "3/1",
        "a2c1",
        "d2c2",
        "endturn",
        "1/4",
        "endturn",
        "5/2",
        "c2c1",
        "c1e1",
        "endturn",
        "2/6",
        "endturn",
        "6/3",
        "f2a1",
        "a1d1",
        "endturn",
        "3/4",
        "s@j1",
        "j1f1",
        "endturn",
        "6/3",
        "s@j2",
        "d1j1",
        "endturn",
        "1/6",
        "f1a2",
        "a2b2",
        "endturn",
        "6/4",
        "e1k1",
        "c1g1",
        "endturn",
        "6/6",
        "b2h2",
        "^g2",
        "^g2",
        "^g2",
        "endturn",
        "2/2",
        "j2h2",
        "h2f2",
        "f2d2",
        "d2b2",
        "endturn",
        "1/1",
        "endturn",
        "1/3",
        "h1k1",
        "k1l1",
        "endturn",
        "6/4",
        "endturn",
        "1/4",
        "g1k1",
        "k1l1",
        "endturn",
        "3/5",
        "s@h1",
        "h1e1",
        "endturn",
        "1/4",
        "s@i2",
        "i2h2",
        "endturn"
      )
      // 5/2 would not involve a capture if it were 5/2 or 2/5 so its a forcedPair
      playActionStrs(actionStrs ++ List("5/2")) must beValid.like { g =>
        g.situation.canMove must_== true
        g.situation.canDrop must_== false
        g.situation.canLift must_== false
        g.situation.forcedAction.nonEmpty must_== true
      }
      playActionStrs(actionStrs ++ List("5/2", "e1a2")) must beValid.like { g =>
        g.situation.canMove must_== true
        g.situation.canDrop must_== false
        g.situation.canLift must_== false
        g.situation.forcedAction.nonEmpty must_== true
        g.situation.board.history.forcedTurn must_== true
      }
      // 6/1 would involve a capture if it were 6/1 but not if it were 1/6 so its not a forcedPair
      playActionStrs(actionStrs ++ List("6/1")) must beValid.like { g =>
        g.situation.canMove must_== true
        g.situation.canDrop must_== false
        g.situation.canLift must_== false
        g.situation.forcedAction.isEmpty must_== true
      }
    }

    "have forced actions when rolling a double and only three of the four moves are a choice (one is forced)" in {
      // https://playstrategy.org/mFEOCGzp/p1/analysis turn 9 (Black 5/5)
      val actionStrs = List(
        "1/2",
        "a2b1",
        "g1h1",
        "endturn",
        "5/1",
        "a1e2",
        "l1k1",
        "endturn",
        "6/1",
        "g1h1",
        "l2f2",
        "endturn",
        "3/1",
        "e2h2",
        "g2h2",
        "endturn",
        "1/2",
        "a2b1",
        "l2k2",
        "endturn",
        "3/4",
        "a1d2",
        "d2g2",
        "endturn",
        "6/4",
        "e1k1",
        "g1k1",
        "endturn",
        "3/5",
        "s@j1",
        "a1e2",
        "endturn",
        "5/3",
        "k2f2",
        "a2c1",
        "endturn",
        "3/1",
        "l1i1",
        "j1i1",
        "endturn",
        "4/1",
        "a2d1",
        "c1d1",
        "endturn",
        "5/5",
        "e2j2",
        "e2j2",
        "g2l2",
        "g2l2",
        "endturn",
        "4/3",
        "a2d1",
        "d1g1",
        "endturn",
        "1/5",
        "a1e2",
        "a1a2",
        "endturn",
        "1/3",
        "g1j1",
        "j1k1",
        "endturn",
        "3/2",
        "e2h2",
        "a2c2",
        "endturn",
        "2/4",
        "h1l1",
        "h1j1",
        "endturn",
        "5/5"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.canMove must_== true
        g.situation.canDrop must_== false
        g.situation.canLift must_== false
        g.situation.board.unusedDice.size must_== 4
        g.situation.forcedAction.nonEmpty must_== true
      }
    }

    // forced single lift (pieces on 5,3,2 points, roll of 5/3)
    "have forced actions when lifting with no options" in {
      val actionStrs = List(
        "3/1",
        "e2h2",
        "g2h2",
        "endturn",
        "2/6",
        "e1k1",
        "g1i1",
        "endturn",
        "1/4",
        "l1h1",
        "l1k1",
        "endturn",
        "2/5",
        "s@k2",
        "e1j1",
        "endturn",
        "6/1",
        "k1e1",
        "g2h2",
        "endturn",
        "6/6",
        "endturn",
        "6/2",
        "e2k2",
        "e1c1",
        "endturn",
        "5/4",
        "s@i2",
        "endturn",
        "3/6",
        "a1f2",
        "f2i2",
        "endturn",
        "3/2",
        "s@j2",
        "s@k2",
        "endturn",
        "3/5",
        "s@j1",
        "e2j2",
        "endturn",
        "5/4",
        "s@i2",
        "endturn",
        "1/3",
        "s@j1",
        "j1i1",
        "endturn",
        "4/1",
        "s@i2",
        "s@l2",
        "endturn",
        "1/2",
        "h2j2",
        "j2k2",
        "endturn",
        "4/1",
        "s@l2",
        "a2d1",
        "endturn",
        "2/6",
        "j1d1",
        "d1b1",
        "endturn",
        "3/6",
        "s@j2",
        "a2f1",
        "endturn",
        "1/1",
        "s@l1",
        "b1a1",
        "c1b1",
        "b1a1",
        "endturn",
        "6/3",
        "i2c2",
        "i2f2",
        "endturn",
        "5/6",
        "l1f1",
        "f1a1",
        "endturn",
        "5/3",
        "s@j2",
        "a2e1",
        "endturn",
        "3/1",
        "a1c2",
        "c2d2",
        "endturn",
        "3/2",
        "s@j2",
        "a2b1",
        "endturn",
        "6/1",
        "a1f2",
        "f2g2",
        "endturn",
        "3/1",
        "s@l2",
        "l2i2",
        "endturn",
        "6/5",
        "h1b1",
        "b1d2",
        "endturn",
        "2/4",
        "s@i2",
        "a2b1",
        "endturn",
        "1/1",
        "i1h1",
        "a1a2",
        "a1a2",
        "a1a2",
        "endturn",
        "2/6",
        "l2f2",
        "e1g1",
        "endturn",
        "2/2",
        "d2f2",
        "d2f2",
        "a2c2",
        "a2c2",
        "endturn",
        "3/4",
        "s@i2",
        "b1e1",
        "endturn",
        "6/1",
        "h1b1",
        "a1a2",
        "endturn",
        "6/2",
        "e1g1",
        "j2d2",
        "endturn",
        "2/1",
        "c2d2",
        "d2f2",
        "endturn",
        "6/5",
        "endturn",
        "3/5",
        "f2k2",
        "a1c2",
        "endturn",
        "4/1",
        "s@i2",
        "j2i2",
        "endturn",
        "2/2",
        "f2h2",
        "f2h2",
        "h2j2",
        "h2j2",
        "endturn",
        "2/6",
        "endturn",
        "6/2",
        "b1e2",
        "e2g2",
        "endturn",
        "1/5",
        "s@l2",
        "g1l1",
        "endturn",
        "5/3",
        "c2h2",
        "c2f2",
        "endturn",
        "1/6",
        "i2c2",
        "c2b2",
        "endturn",
        "2/5",
        "f2k2",
        "h2j2",
        "endturn",
        "5/6",
        "b2e1",
        "e1j1",
        "endturn",
        "3/2",
        "a2d2",
        "d2f2",
        "endturn",
        "1/3",
        "g1j1",
        "g1h1",
        "endturn",
        "1/5",
        "f2k2",
        "a2b2",
        "endturn",
        "4/6",
        "i2c2",
        "c2b1",
        "endturn",
        "3/6",
        "b2h2",
        "^j2",
        "endturn",
        "4/2",
        "b1f1",
        "f1h1",
        "endturn",
        "6/3",
        "^g2",
        "g2j2",
        "endturn",
        "3/4",
        "g1k1",
        "g1j1",
        "endturn",
        "5/1",
        "^h2",
        "g2h2",
        "endturn",
        "2/6",
        "i2c2",
        "c2a2",
        "endturn",
        "3/4",
        "g2k2",
        "g2j2",
        "endturn",
        "3/1",
        "a2c1",
        "c1d1",
        "endturn",
        "6/4",
        "^h2",
        "endturn",
        "3/6",
        "d1j1",
        "g1j1",
        "endturn",
        "5/3"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.canMove must_== true
        g.situation.canDrop must_== false
        g.situation.canLift must_== true
        g.situation.forcedAction.nonEmpty must_== true
      }
      playActionStrs(actionStrs ++ List("^h2")) must beValid.like { g =>
        g.situation.canMove must_== true
        g.situation.canDrop must_== false
        g.situation.canLift must_== true
        g.situation.forcedAction.isEmpty must_== true
        g.situation.board.history.forcedTurn must_== true
      }
    }

    // forced double lifts e.g. 6/5
    "have forced actions when lifting with no options" in {
      val actionStrs = List(
        "5/4",
        "l1h1",
        "h1c1",
        "endturn",
        "4/2",
        "e1i1",
        "g1i1",
        "endturn",
        "2/4",
        "e2i2",
        "g2i2",
        "endturn",
        "1/2",
        "a2b1",
        "b1c1",
        "endturn",
        "6/6",
        "endturn",
        "1/6",
        "c1i1",
        "l2k2",
        "endturn",
        "6/4",
        "endturn",
        "5/5",
        "g1l1",
        "g1l1",
        "a2e1",
        "a2e1",
        "endturn",
        "1/6",
        "endturn",
        "4/6",
        "l2f2",
        "f2b2",
        "endturn",
        "3/5",
        "s@h1",
        "s@j1",
        "endturn",
        "5/3",
        "b2d1",
        "d1g1",
        "endturn",
        "5/4",
        "j1f1",
        "h1c1",
        "endturn",
        "3/4",
        "a2c1",
        "c1g1",
        "endturn",
        "3/1",
        "s@j1",
        "a1a2",
        "endturn",
        "6/5",
        "s@h2",
        "h2b2",
        "endturn",
        "2/4",
        "a2e2",
        "a1b2",
        "endturn",
        "3/1",
        "s@j2",
        "k2j2",
        "endturn",
        "4/6",
        "j1f1",
        "b2h2",
        "endturn",
        "6/2",
        "j2h2",
        "h2b2",
        "endturn",
        "1/3",
        "s@j1",
        "a1a2",
        "endturn",
        "3/2",
        "g1j1",
        "j1l1",
        "endturn",
        "1/3",
        "s@j1",
        "a2b2",
        "endturn",
        "1/6",
        "s@l2",
        "j2d2",
        "endturn",
        "2/6",
        "b2d2",
        "j1d1",
        "endturn",
        "6/5",
        "s@h2",
        "l2f2",
        "endturn",
        "3/5",
        "d2i2",
        "d1a1",
        "endturn",
        "2/5",
        "f2a2",
        "a2b1",
        "endturn",
        "6/6",
        "f1a2",
        "f1a2",
        "a2g2",
        "a2g2",
        "endturn",
        "2/6",
        "h2b2",
        "b1d1",
        "endturn",
        "6/6",
        "a1f2",
        "a1f2",
        "a1f2",
        "e2k2",
        "endturn",
        "6/4",
        "b2e1",
        "d1h1",
        "endturn",
        "2/3",
        "e2h2",
        "e2g2",
        "endturn",
        "1/5",
        "e1j1",
        "e1f1",
        "endturn",
        "3/1",
        "f2i2",
        "f2g2",
        "endturn",
        "5/6",
        "e1k1",
        "e1j1",
        "endturn",
        "5/3",
        "f2k2",
        "g2j2",
        "endturn",
        "5/2",
        "e1j1",
        "f1h1",
        "endturn",
        "3/2",
        "^j2",
        "^k2",
        "endturn",
        "2/5",
        "^h1",
        "^k1",
        "endturn",
        "3/2",
        "g2j2",
        "^k2",
        "endturn",
        "4/4",
        "^i1",
        "^i1",
        "^i1",
        "g1k1",
        "endturn",
        "6/2",
        "^g2",
        "g2i2",
        "endturn",
        "3/3",
        "^j1",
        "^j1",
        "^j1",
        "g1j1",
        "endturn",
        "2/6",
        "^g2",
        "g2i2",
        "endturn",
        "1/2",
        "g1i1",
        "^l1",
        "endturn",
        "1/2",
        "g2h2",
        "g2i2",
        "endturn",
        "6/5"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.canLift must_== true
        g.situation.board.unusedDice.size must_== 2
        g.situation.forcedAction.nonEmpty must_== true
      }
    }

    "have forced actions when forcedSingle is true" in {
      val actionStrs = List(
        "3/1",
        "e2h2",
        "g2h2",
        "endturn",
        "2/6",
        "e1k1",
        "g1i1",
        "endturn",
        "1/4",
        "l1h1",
        "l1k1",
        "endturn",
        "2/5",
        "s@k2",
        "e1j1",
        "endturn",
        "6/1",
        "k1e1",
        "g2h2",
        "endturn",
        "6/6",
        "endturn",
        "6/2",
        "e2k2",
        "e1c1",
        "endturn",
        "5/4",
        "s@i2",
        "endturn",
        "3/6",
        "a1f2",
        "f2i2",
        "endturn",
        "3/2",
        "s@j2",
        "s@k2",
        "endturn",
        "3/5",
        "s@j1",
        "e2j2",
        "endturn",
        "5/4",
        "s@i2",
        "endturn",
        "1/3",
        "s@j1",
        "j1i1",
        "endturn",
        "4/1",
        "s@i2",
        "s@l2",
        "endturn",
        "1/2",
        "h2j2",
        "j2k2",
        "endturn",
        "4/1",
        "s@l2",
        "a2d1",
        "endturn",
        "2/6",
        "j1d1",
        "d1b1",
        "endturn",
        "3/6",
        "s@j2",
        "a2f1",
        "endturn",
        "1/1",
        "s@l1",
        "b1a1",
        "c1b1",
        "b1a1",
        "endturn",
        "6/3",
        "i2c2",
        "i2f2",
        "endturn",
        "5/6",
        "l1f1",
        "f1a1",
        "endturn",
        "5/3",
        "s@j2",
        "a2e1",
        "endturn",
        "3/1",
        "a1c2",
        "c2d2",
        "endturn",
        "3/2",
        "s@j2",
        "a2b1",
        "endturn",
        "6/1",
        "a1f2",
        "f2g2",
        "endturn",
        "3/1",
        "s@l2",
        "l2i2",
        "endturn",
        "6/5",
        "h1b1",
        "b1d2",
        "endturn",
        "2/4",
        "s@i2",
        "a2b1",
        "endturn",
        "1/1",
        "i1h1",
        "a1a2",
        "a1a2",
        "a1a2",
        "endturn",
        "2/6",
        "l2f2",
        "e1g1",
        "endturn",
        "2/2",
        "d2f2",
        "d2f2",
        "a2c2",
        "a2c2",
        "endturn",
        "3/4",
        "s@i2",
        "b1e1",
        "endturn",
        "6/1",
        "h1b1",
        "a1a2",
        "endturn",
        "6/2",
        "e1g1",
        "j2d2",
        "endturn",
        "2/1",
        "c2d2",
        "d2f2",
        "endturn",
        "6/5",
        "endturn",
        "3/5",
        "f2k2",
        "a1c2",
        "endturn",
        "4/1",
        "s@i2",
        "j2i2",
        "endturn",
        "2/2",
        "f2h2",
        "f2h2",
        "h2j2",
        "h2j2",
        "endturn",
        "2/6",
        "endturn",
        "6/2",
        "b1e2",
        "e2g2",
        "endturn",
        "1/5",
        "s@l2",
        "g1l1",
        "endturn",
        "5/3",
        "c2h2",
        "c2f2",
        "endturn",
        "1/6",
        "i2c2",
        "c2b2",
        "endturn",
        "2/5",
        "f2k2",
        "h2j2",
        "endturn",
        "5/6",
        "b2e1",
        "e1j1",
        "endturn",
        "3/2",
        "a2d2",
        "d2f2",
        "endturn",
        "1/3",
        "g1j1",
        "g1h1",
        "endturn",
        "1/5",
        "f2k2",
        "a2b2",
        "endturn",
        "4/6",
        "i2c2",
        "c2b1",
        "endturn",
        "3/6"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.forcedAction.map(_.toUci.uci) must_== Some("b2h2")
      }
      // Undoing, and playing a non forced action should not result in a forcedTurn
      playActionStrs(actionStrs ++ List("g2j2", "b2h2")) must beValid.like { g =>
        g.situation.board.history.forcedTurn must_== false
      }
    }

    "have correct forced action when forcedSingle is true" in {
      val actionStrs = List(
        "3/2",
        "g2j2",
        "g2i2",
        "endturn",
        "4/2",
        "e1i1",
        "g1i1",
        "endturn",
        "3/1",
        "e2h2",
        "l1k1",
        "endturn",
        "6/4",
        "e1k1",
        "l2h2",
        "endturn",
        "6/2",
        "s@k1",
        "endturn",
        "2/6",
        "s@k2",
        "e1k1",
        "endturn",
        "1/4",
        "s@l1",
        "endturn",
        "6/4",
        "a2f1",
        "a2d1",
        "endturn",
        "5/5",
        "s@h1",
        "g2l2",
        "a1e2",
        "a1e2",
        "endturn",
        "4/1",
        "s@i2",
        "k2j2",
        "endturn",
        "2/5",
        "s@k1",
        "s@h1",
        "endturn",
        "1/2",
        "s@k2",
        "d1e1",
        "endturn",
        "5/2",
        "h1c1",
        "c1a1",
        "endturn",
        "5/6",
        "a2f1",
        "a2e1",
        "endturn",
        "2/2",
        "a1b2",
        "a1b2",
        "l1j1",
        "l1j1",
        "endturn",
        "6/5",
        "i2c2",
        "h2c2",
        "endturn",
        "1/4",
        "h1d1",
        "k1j1",
        "endturn",
        "3/4",
        "a2c1",
        "c1g1",
        "endturn",
        "5/4",
        "d1b2",
        "e2i2",
        "endturn",
        "5/6",
        "j2d2",
        "d2b1",
        "endturn",
        "1/3",
        "e2h2",
        "h2i2",
        "endturn",
        "2/4",
        "c2b1",
        "c2a2",
        "endturn",
        "3/1",
        "b2e2",
        "b2c2",
        "endturn",
        "1/1",
        "k2j2",
        "g1h1",
        "g1h1",
        "g1h1",
        "endturn",
        "1/1",
        "e2f2",
        "c2d2",
        "d2e2",
        "e2f2",
        "endturn",
        "4/4",
        "a2d1",
        "d1h1",
        "e1i1",
        "e1i1",
        "endturn",
        "5/5",
        "j1e1",
        "j1e1",
        "j1e1",
        "e1a2",
        "endturn",
        "3/6",
        "j2d2",
        "f1i1",
        "endturn",
        "6/4",
        "e1b2",
        "a1d2",
        "endturn",
        "4/1",
        "s@l2",
        "l2h2",
        "endturn",
        "6/3",
        "s@j1",
        "j1d1",
        "endturn",
        "5/3",
        "h2c2",
        "f1i1",
        "endturn",
        "5/4",
        "d2i2",
        "b2f2",
        "endturn",
        "2/6",
        "b1h1",
        "h1j1",
        "endturn",
        "1/5",
        "d1b2",
        "b2c2",
        "endturn",
        "1/1",
        "s@l2",
        "l2k2",
        "k2j2",
        "i1j1",
        "endturn",
        "5/3",
        "e1b1",
        "b2g2",
        "endturn",
        "1/3",
        "s@j2",
        "i1j1",
        "endturn",
        "1/6",
        "b1e2",
        "a1a2",
        "endturn",
        "2/2",
        "j2h2",
        "j2h2",
        "i1k1",
        "i1k1",
        "endturn",
        "4/5",
        "c2g2",
        "e2j2",
        "endturn",
        "1/3",
        "h1k1",
        "h1i1",
        "endturn",
        "4/5",
        "e2j2",
        "e2i2",
        "endturn",
        "3/6"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.forcedAction.map(_.toUci.uci) must_== Some("h2b2")
      }
    }

    "not have forced actions when lift and move are valid options" in {
      val actionStrs = List(
        "1/3",
        "e1h1",
        "g1h1",
        "endturn",
        "6/3",
        "l1f1",
        "a1c2",
        "endturn",
        "1/5",
        "a2e1",
        "e1f1",
        "endturn",
        "6/1",
        "s@l1",
        "l1f1",
        "endturn",
        "2/3",
        "s@k2",
        "k2h2",
        "endturn",
        "1/4",
        "a1d2",
        "c2d2",
        "endturn",
        "3/5",
        "a2e1",
        "e1h1",
        "endturn",
        "6/3",
        "f1c1",
        "c1d2",
        "endturn",
        "3/4",
        "g1k1",
        "h1k1",
        "endturn",
        "6/3",
        "d2j2",
        "g2j2",
        "endturn",
        "4/3",
        "a2d1",
        "d1g1",
        "endturn",
        "4/4",
        "d2h2",
        "d2h2",
        "a1d2",
        "a1d2",
        "endturn",
        "4/5",
        "s@i2",
        "g1l1",
        "endturn",
        "5/1",
        "s@l1",
        "a1e2",
        "endturn",
        "5/1",
        "s@l2",
        "g1l1",
        "endturn",
        "3/6",
        "s@j1",
        "j1d1",
        "endturn",
        "2/5",
        "e1j1",
        "j1l1",
        "endturn",
        "4/2",
        "e2i2",
        "g2i2",
        "endturn",
        "5/5",
        "endturn",
        "1/1",
        "e2f2",
        "e2f2",
        "d1c1",
        "c1b1",
        "endturn",
        "5/4",
        "endturn",
        "2/2",
        "e2g2",
        "g2i2",
        "d2f2",
        "d2f2",
        "endturn",
        "4/3",
        "endturn",
        "5/6",
        "b1e2",
        "e2j2",
        "endturn",
        "4/1",
        "s@l2",
        "e1i1",
        "endturn",
        "4/1",
        "f2j2",
        "f2g2",
        "endturn",
        "2/4",
        "g1k1",
        "g1i1",
        "endturn",
        "4/1",
        "g2k2",
        "j2k2",
        "endturn",
        "3/3",
        "a2c1",
        "h1k1",
        "h1k1",
        "a2c1",
        "endturn",
        "6/5",
        "f2k2",
        "endturn",
        "6/5",
        "l2f2",
        "f2a2",
        "endturn",
        "3/2",
        "s@j1",
        "j1h1",
        "endturn",
        "4/6",
        "a2f1",
        "f1j1",
        "endturn",
        "4/4",
        "h1d1",
        "d1a2",
        "a2e2",
        "e2i2",
        "endturn",
        "6/3",
        "l2f2",
        "f2c2",
        "endturn",
        "3/6",
        "^g2",
        "^j2",
        "endturn",
        "3/4",
        "c1f1",
        "f1j1",
        "endturn",
        "2/6",
        "^g2",
        "g2i2",
        "endturn",
        "4/5",
        "c1g1",
        "g1l1",
        "endturn",
        "4/1",
        "^i2",
        "i2j2",
        "endturn",
        "5/3",
        "c2c1",
        "c1f1",
        "endturn",
        "4/5",
        "^h2",
        "^i2",
        "endturn",
        "1/5",
        "f1g1",
        "g1l1",
        "endturn",
        "2/6",
        "^h2",
        "^k2",
        "endturn",
        "1/6",
        "l2f2",
        "k1l1",
        "endturn",
        "6/4",
        "^i2",
        "^i2",
        "endturn",
        "2/3",
        "f2c2",
        "c2a2",
        "endturn",
        "2/1",
        "j2l2",
        "^l2",
        "endturn",
        "2/6",
        "s@g2",
        "g2e2",
        "endturn",
        "3/2",
        "^k2",
        "^j2",
        "endturn",
        "1/2",
        "e2d2",
        "d2b2",
        "endturn",
        "3/2"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.forcedAction.isEmpty must_== true
      }
    }

    "not have forced actions when a capture is part of the other path" in {
      val actionStrs = List(
        "5/6",
        "l2f2",
        "f2a2",
        "endturn",
        "3/5",
        "e2j2",
        "g2j2",
        "endturn",
        "4/4",
        "g1k1",
        "g1k1",
        "a2d1",
        "a2d1",
        "endturn",
        "2/6",
        "a1f2",
        "g2i2",
        "endturn",
        "2/4",
        "e1i1",
        "g1i1",
        "endturn",
        "3/1",
        "e2h2",
        "j2k2",
        "endturn",
        "4/5",
        "l2h2",
        "h2c2",
        "endturn",
        "5/5",
        "s@h1",
        "a1e2",
        "e2j2",
        "g2l2",
        "endturn",
        "1/2",
        "c2a2",
        "g1h1",
        "endturn",
        "6/2",
        "s@g1",
        "l1j1",
        "endturn",
        "5/3",
        "s@h2",
        "i1l1",
        "endturn",
        "3/2",
        "s@j1",
        "g2i2",
        "endturn",
        "5/2",
        "d1i1",
        "a2b1",
        "endturn",
        "6/6",
        "a1f2",
        "f2l2",
        "a1f2",
        "f2l2",
        "endturn",
        "3/2",
        "i1l1",
        "b1d1",
        "endturn",
        "4/4",
        "g1c1",
        "c1b2",
        "b2f2",
        "f2j2",
        "endturn",
        "4/3",
        "e1i1",
        "e1h1",
        "endturn",
        "6/1",
        "a1f2",
        "f2g2",
        "endturn",
        "5/5",
        "a2e1",
        "a2e1",
        "a2e1",
        "a2e1",
        "endturn",
        "2/5",
        "g2l2",
        "i2k2",
        "endturn",
        "2/3",
        "d1g1",
        "e1g1",
        "endturn",
        "3/4",
        "g2k2",
        "i2l2",
        "endturn",
        "4/6",
        "d1h1",
        "e1k1",
        "endturn",
        "5/5",
        "e2j2",
        "f2k2",
        "endturn",
        "2/1",
        "h2f2",
        "f2e2",
        "endturn",
        "2/4",
        "j1f1",
        "f1d1",
        "endturn",
        "4/2",
        "e2a2",
        "a2b1",
        "endturn",
        "5/5",
        "d1b2",
        "b2g2",
        "g2l2",
        "endturn",
        "3/2",
        "g1j1",
        "h1j1",
        "endturn",
        "5/3",
        "endturn",
        "5/1",
        "b1g1",
        "e1f1",
        "endturn",
        "2/3",
        "endturn",
        "5/2",
        "e1j1",
        "f1h1",
        "endturn",
        "1/4",
        "endturn",
        "3/6",
        "^g1",
        "^j1",
        "endturn",
        "4/3",
        "endturn",
        "1/3",
        "^j1",
        "k1l1",
        "endturn",
        "3/5",
        "s@j1",
        "j1e1",
        "endturn",
        "5/5",
        "s@h2",
        "h2c2",
        "c2c1",
        "g1l1",
        "endturn",
        "3/2"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.canCapture must_== true
        g.situation.forcedAction.isEmpty must_== true
      }
    }

    "have forced actions for double move when lift is only other option" in {
      val actionStrs = List(
        "3/4",
        "l2h2",
        "l2i2",
        "endturn",
        "5/4",
        "e2j2",
        "g2k2",
        "endturn",
        "5/1",
        "h2c2",
        "c2b2",
        "endturn",
        "2/5",
        "l1j1",
        "a1e2",
        "endturn",
        "4/5",
        "b2d1",
        "a2d1",
        "endturn",
        "6/2",
        "l1f1",
        "a1b2",
        "endturn",
        "6/1",
        "a2f1",
        "e1f1",
        "endturn",
        "2/4",
        "s@i1",
        "j1h1",
        "endturn",
        "6/5",
        "i2c2",
        "c2c1",
        "endturn",
        "3/5",
        "a1e2",
        "a1c2",
        "endturn",
        "4/6",
        "c1i1",
        "e1i1",
        "endturn",
        "4/2",
        "s@k1",
        "e2i2",
        "endturn",
        "6/1",
        "a2a1",
        "a2f1",
        "endturn",
        "6/4",
        "endturn",
        "5/4",
        "e1j1",
        "f1j1",
        "endturn",
        "6/1",
        "s@l1",
        "c2i2",
        "endturn",
        "4/4",
        "d1h1",
        "d1h1",
        "g1k1",
        "g1k1",
        "endturn",
        "2/1",
        "s@l1",
        "endturn",
        "3/3",
        "a2c1",
        "c1f1",
        "a1d1",
        "d1g1",
        "endturn",
        "1/3",
        "s@l1",
        "e2h2",
        "endturn",
        "3/3",
        "f1i1",
        "f1i1",
        "g1j1",
        "g1j1",
        "endturn",
        "5/5",
        "g2l2",
        "b2g2",
        "e2j2",
        "e2j2",
        "endturn",
        "1/5",
        "f1k1",
        "j1k1",
        "endturn",
        "5/1",
        "g2l2",
        "k2l2",
        "endturn",
        "4/3",
        "^i1",
        "^j1",
        "endturn",
        "2/2",
        "j2l2",
        "j2l2",
        "j2l2",
        "i2k2",
        "endturn",
        "2/2",
        "i1k1",
        "i1k1",
        "i1k1",
        "^k1",
        "endturn",
        "1/5",
        "g2l2",
        "k2l2",
        "endturn",
        "3/5",
        "^h1",
        "g1j1",
        "endturn",
        "3/2",
        "l1i1",
        "i1g1",
        "endturn",
        "5/2",
        "s@k2",
        "k2f2",
        "endturn",
        "5/5",
        "g1b1",
        "b1d2",
        "g2l2",
        "g2l2",
        "endturn",
        "4/2",
        "f2b2",
        "h1j1",
        "endturn",
        "4/1",
        "l1h1",
        "h1g1",
        "endturn",
        "1/1",
        "j1k1",
        "j1k1",
        "j1k1",
        "j1k1",
        "endturn",
        "6/2",
        "d2j2",
        "j2l2",
        "endturn",
        "3/2"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.canMove must_== true
        g.situation.forcedAction.nonEmpty must_== true
      }
      playActionStrs(actionStrs ++ List("b2b1")) must beValid.like { g =>
        g.situation.canMove must_== true
        g.situation.forcedAction.nonEmpty must_== true
        g.situation.board.history.forcedTurn must_== true
      }
      playActionStrs(actionStrs ++ List("b2b1", "b1d1")) must beValid.like { g =>
        g.situation.canOnlyEndTurn must_== true
        g.situation.forcedAction.nonEmpty must_== true
        g.situation.board.history.forcedTurn must_== true
      }
    }

    "not have forced actions when piece has to move but neither dice is forced" in {
      val actionStrs = List(
        "6/2",
        "l1f1",
        "a1b2",
        "endturn",
        "2/2",
        "g1i1",
        "g1i1",
        "a2b1",
        "a2b1",
        "endturn",
        "6/4",
        "e2k2",
        "g2k2",
        "endturn",
        "1/3",
        "e1h1",
        "g1h1",
        "endturn",
        "3/6",
        "l1f1",
        "b2e2",
        "endturn",
        "4/5",
        "a2e1",
        "l2h2",
        "endturn",
        "1/4",
        "a1d2",
        "d2e2",
        "endturn",
        "1/2",
        "b1d1",
        "d1e1",
        "endturn",
        "4/2",
        "f1b1",
        "f1d1",
        "endturn",
        "5/2",
        "s@h2",
        "a2b1",
        "endturn",
        "1/1",
        "s@l1",
        "d1c1",
        "c1b1",
        "a1a2",
        "endturn",
        "1/6",
        "s@l2",
        "endturn",
        "5/6",
        "a1f2",
        "a2f2",
        "endturn",
        "3/1",
        "s@l2",
        "e1h1",
        "endturn",
        "2/2",
        "g2i2",
        "g2i2",
        "l1j1",
        "e2g2",
        "endturn",
        "5/3",
        "h2c2",
        "c2a1",
        "endturn",
        "5/3",
        "s@j1",
        "b1d2",
        "endturn",
        "4/3",
        "h2d2",
        "d2a2",
        "endturn",
        "5/2",
        "s@k1",
        "k1f1",
        "endturn",
        "6/1",
        "a2f1",
        "e1f1",
        "endturn",
        "6/5",
        "endturn",
        "2/6",
        "l2j2",
        "j2d2",
        "endturn",
        "6/2",
        "s@k1",
        "j1d1",
        "endturn",
        "1/4",
        "d2a1",
        "h1i1",
        "endturn",
        "5/6",
        "j1d1",
        "d1b2",
        "endturn",
        "5/6",
        "a1g1",
        "a1f1",
        "endturn",
        "5/2",
        "b2g2",
        "d1b1",
        "endturn",
        "6/1",
        "f1l1",
        "g1h1",
        "endturn",
        "5/6",
        "b1e2",
        "e2j2",
        "endturn",
        "6/2",
        "l2j2",
        "f1l1",
        "endturn",
        "3/3",
        "s@j1",
        "g2j2",
        "g2j2",
        "e2h2",
        "endturn",
        "1/6",
        "s@l2",
        "f1l1",
        "endturn",
        "3/1",
        "e2h2",
        "e2f2",
        "endturn",
        "6/3",
        "e1k1",
        "h1k1",
        "endturn",
        "2/2",
        "endturn",
        "2/2",
        "h1j1",
        "h1j1",
        "e1g1",
        "i1k1",
        "endturn",
        "5/1",
        "s@h1",
        "endturn",
        "4/3",
        "g1k1",
        "g1j1",
        "endturn",
        "2/4",
        "endturn",
        "2/5",
        "g1l1",
        "j1l1",
        "endturn",
        "6/1",
        "s@g1",
        "g1f1",
        "endturn",
        "5/5",
        "endturn",
        "2/2",
        "f1d1",
        "d1b1",
        "b1a2",
        "h1f1",
        "endturn",
        "6/2",
        "i1k1",
        "endturn",
        "6/5",
        "a2g2",
        "f1a1",
        "endturn",
        "3/1",
        "i1l1",
        "k1l1",
        "endturn",
        "1/4",
        "a1d2",
        "d2e2",
        "endturn",
        "4/2",
        "j1l1",
        "endturn",
        "2/1",
        "e2g2",
        "g2h2",
        "endturn",
        "6/3",
        "endturn",
        "4/6",
        "f2j2",
        "endturn",
        "5/1",
        "j1k1",
        "endturn",
        "3/3",
        "f2i2",
        "f2i2",
        "g2j2",
        "^j2",
        "endturn",
        "6/6",
        "l2f2",
        "l2f2",
        "f2a1",
        "a1g1",
        "endturn",
        "1/2",
        "j2l2",
        "^l2",
        "endturn",
        "2/3",
        "f2c2",
        "c2a2",
        "endturn",
        "5/3",
        "^h2",
        "^j2",
        "endturn",
        "4/3"
      )
      playActionStrs(actionStrs) must beValid.like { g =>
        g.situation.canMove must_== true
        g.situation.forcedAction.isEmpty must_== true
      }
    }
  }

  "A Hyper Backgammon game " should {
    "have 3 moves from start" in {
      val actionStrs = List(
        "4/2",
        "l1h1"
      )
      playActionStrs(actionStrs, Some(Game.apply(variant.Hyper))) must beValid.like { g =>
        g.situation.moves.values.flatten.map(_.toUci.uci).toSet must_== Set("h1f1", "j1h1", "k1i1")
      }
    }

    "end in single win even if in backgammon position" in {
      val actionStrs = List(
        "endturn",
        "6/2",
        "l1j1",
        "k1e1",
        "endturn",
        "3/1",
        "l2i2",
        "j2i2",
        "endturn",
        "4/4",
        "j1f1",
        "f1b1",
        "b1c2",
        "c2g2",
        "endturn",
        "6/4",
        "k2e2",
        "e2a2",
        "endturn",
        "6/6",
        "e1b2",
        "b2h2",
        "j1d1",
        "d1c2",
        "endturn",
        "2/1",
        "a2a1",
        "a1c1",
        "endturn",
        "5/5",
        "c2h2",
        "g2l2",
        "^h2",
        "^h2",
        "endturn",
        "2/1",
        "c1d1",
        "d1f1",
        "endturn",
        "1/2",
        "^l2"
      )
      playActionStrs(actionStrs, Some(Game.apply(variant.Hyper))) must beValid.like { g =>
        g.situation.board.history.score must_== Score(0, 3)
        g.situation.end must_== true
        g.situation.board.pieceInOpponentsHome(Player.P1) must_== true
        g.situation.winner must_== Some(Player.P2)
        g.situation.status must_== Some(Status.SingleWin) // not a backgammon due to no double of cube
      }
    }
  }

}

class BackgammonVariantTestIsometry extends strategygames.chess.ChessTest {

  val bgGameP2StartsActionStrs = Vector(
    Vector("endturn"),
    Vector("3/1", "e2h2", "g2h2", "endturn"),
    Vector("5/3", "e1j1", "l2i2", "endturn"),
    Vector("4/4", "e2i2", "e2i2", "a1d2", "a1d2", "endturn"),
    Vector("3/1", "s@j2", "g1h1", "endturn"),
    Vector("1/6", "g2h2", "l1f1", "endturn"),
    Vector("5/5", "g1l1", "j2e2", "a2e1", "a2e1", "endturn"),
    Vector("1/2", "s@l1", "l1j1", "endturn"),
    Vector("6/5", "endturn"),
    Vector("5/1", "f1a1", "j1i1", "endturn"),
    Vector("5/3", "s@j2", "endturn"),
    Vector("2/4", "a1b2", "b2f2", "endturn"),
    Vector("1/3", "s@j2", "e1f1", "endturn"),
    Vector("3/1", "i1f1", "d2e2", "endturn"),
    Vector("1/3", "s@j2", "s@l2", "endturn"),
    Vector("5/4", "f2k2", "g2k2", "endturn"),
    Vector("2/5", "l2j2", "e1j1", "endturn"),
    Vector("4/1", "e2i2", "d2e2", "endturn"),
    Vector("6/6", "j2d2", "j2d2", "j2d2", "d2c1", "endturn"),
    Vector("1/3", "f1c1", "c1b1", "endturn"),
    Vector("6/6", "endturn"),
    Vector("5/2", "a1e2", "a1b2", "endturn"),
    Vector("4/2", "endturn"),
    Vector("2/5", "h2j2", "e2j2", "endturn"),
    Vector("1/5", "s@l2", "endturn"),
    Vector("6/4", "b2h2", "b1c2", "endturn"),
    Vector("2/6", "endturn"),
    Vector("3/6", "a1c2", "e2k2", "endturn"),
    Vector("6/3", "endturn"),
    Vector("5/6", "c2h2", "c2i2", "endturn"),
    Vector("4/3", "endturn"),
    Vector("6/4", "^g2", "g2k2", "endturn"),
    Vector("3/5", "endturn"),
    Vector("3/1", "h2k2", "i2j2", "endturn"),
    Vector("4/5", "endturn"),
    Vector("1/4", "^i2", "h2i2", "endturn"),
    Vector("2/4", "endturn"),
    Vector("5/6", "^h2", "^h2", "endturn"),
    Vector("6/4", "s@g2", "l2h2", "endturn"),
    Vector("4/5", "^i2", "^i2", "endturn"),
    Vector("5/3", "e1j1", "l2i2", "endturn"),
    Vector("4/2", "s@i1", "j2l2", "endturn"),
    Vector("6/4", "e1i1", "h2b2", "endturn"),
    Vector("6/6", "endturn"),
    Vector("1/1", "g1h1", "h1i1", "a2a1", "a2a1", "endturn"),
    Vector("5/3", "s@h1", "h1e1", "endturn"),
    Vector("6/2", "s@g2", "d2b2", "endturn"),
    Vector("1/6", "e1d1", "d1c2", "endturn"),
    Vector("2/2", "g2e2", "e2c2", "a1c1", "a1c1", "endturn"),
    Vector("2/6", "s@k1", "k1e1", "endturn"),
    Vector("1/5", "a2e1", "g2f2", "endturn"),
    Vector("4/6", "endturn"),
    Vector("1/4", "b2a2", "b2c1", "endturn"),
    Vector("1/1", "s@l1", "k2l2", "l1k1", "k2l2", "endturn"),
    Vector("1/6", "e1k1", "c1d1", "endturn"),
    Vector("6/4", "endturn"),
    Vector("6/4", "a2f1", "f1j1", "endturn"),
    Vector("1/5", "s@h1", "k2l2", "endturn"),
    Vector("3/5", "c1h1", "h1k1", "endturn"),
    Vector("4/6", "endturn"),
    Vector("4/4", "c2b1", "d2a1", "f2b2", "b2c1", "endturn"),
    Vector("3/6", "endturn"),
    Vector("5/4", "c1h1", "d1h1", "endturn"),
    Vector("5/1", "s@l1", "endturn"),
    Vector("2/1", "a1c1", "i2h2", "endturn"),
    Vector("5/5", "endturn"),
    Vector("2/5", "h2f2", "b1g1", "endturn"),
    Vector("2/6", "l1f1", "f1d1", "endturn"),
    Vector("1/1", "c1d1", "c1d1", "f2e2", "e2d2", "endturn"),
    Vector("5/1", "s@l1", "endturn"),
    Vector("1/1", "d1e1", "d1e1", "e1f1", "e1f1", "endturn"),
    Vector("3/3", "endturn"),
    Vector("1/4", "d2c2", "c2b1", "endturn"),
    Vector("4/5", "endturn"),
    Vector("2/4", "b1d1", "d1h1", "endturn"),
    Vector("2/4", "j2l2", "endturn"),
    Vector("2/3", "f1h1", "f1i1", "endturn"),
    Vector("1/4", "j2k2", "endturn"),
    Vector("6/3", "^g1", "^j1", "endturn"),
    Vector("4/3", "endturn"),
    Vector("1/6", "g1h1", "^g1", "endturn"),
    Vector("3/4", "endturn"),
    Vector("6/3", "^h1", "i1l1", "endturn"),
    Vector("4/2", "endturn"),
    Vector("1/5", "^l1", "^h1", "endturn"),
    Vector("6/2", "s@g1", "g1e1", "endturn"),
    Vector("6/1", "^h1", "k1l1", "endturn"),
    Vector("2/3", "e1c1", "c1a2", "endturn"),
    Vector("1/4", "^l1", "^i1", "endturn"),
    Vector("1/5", "a2b2", "b2g2", "endturn"),
    Vector("5/6", "^h1", "^h1", "endturn"),
    Vector("3/6", "^g2", "^k2", "endturn"),
    Vector("1/4", "k1l1", "^i1", "endturn"),
    Vector("6/3", "^k2", "^k2", "endturn"),
    Vector("4/1", "^j1", "^l1", "endturn"),
    Vector("3/6", "^l2", "^l2", "endturn"),
    Vector("3/1", "^j1")
  )

  val bgGameP1StartsActionStrs = Vector(
    Vector("2/3", "l2i2", "g1i1", "endturn"),
    Vector("3/1")
  )

  "Test Every move can be loaded from fen P2 starts" in {
    val gameFamily   = Backgammon.gameFamily
    val lib          = gameFamily.gameLogic
    val stratVariant = StratVariant(lib, Backgammon.key).get

    _testEveryMoveLoadFenIsometry(lib, StratFen(lib, Backgammon.initialFen.value), stratVariant)(
      bgGameP2StartsActionStrs.flatten.toList.map(uciStr => StratUci(lib, gameFamily, uciStr).get)
    ) must beValid.like(gameData => {
      val fen1 = StratForsyth.>>(lib, gameData.game)
      val fen2 = StratForsyth.>>(lib, gameData.fenGame)
      fen1 must_== fen2
    })
  }

  "Test Every move can be loaded from fen P1 starts" in {
    val gameFamily   = Backgammon.gameFamily
    val lib          = gameFamily.gameLogic
    val stratVariant = StratVariant(lib, Backgammon.key).get

    _testEveryMoveLoadFenIsometry(lib, StratFen(lib, Backgammon.initialFen.value), stratVariant)(
      bgGameP1StartsActionStrs.flatten.toList.map(uciStr => StratUci(lib, gameFamily, uciStr).get)
    ) must beValid.like(gameData => {
      val fen1 = StratForsyth.>>(lib, gameData.game)
      val fen2 = StratForsyth.>>(lib, gameData.fenGame)
      fen1 must_== fen2
    })
  }
}
